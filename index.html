<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Roguelike TD - Google Sheets Powered</title>
    <style>
        body { margin: 0; background: #222; color: #fff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        #game-container { position: relative; display: flex; justify-content: center; margin-top: 20px; }
        canvas { background: #333; border: 2px solid #555; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        #ui-layer { position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 800px; height: 600px; pointer-events: none; }
        .hud { position: absolute; top: 10px; left: 10px; font-size: 18px; font-weight: bold; pointer-events: auto; }
        
        #draft-screen { 
            display: flex; position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 10;
        }
        #draft-screen h2 { font-size: 32px; color: #ffd700; margin-bottom: 40px; }
        .cards-container { display: flex; gap: 20px; }
        .card { 
            width: 200px; height: 280px; background: #444; border: 2px solid #666; border-radius: 10px; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            cursor: pointer; transition: 0.2s; padding: 20px; text-align: center;
        }
        .card:hover { transform: translateY(-10px); background: #555; border-color: #00bcd4; box-shadow: 0 0 15px #00bcd4; }
        .card h3 { color: #00bcd4; margin-bottom: 10px; }
        .card p { font-size: 14px; color: #ccc; }
        
        #loading-msg { color: #00bcd4; font-size: 24px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        #controls { position: absolute; bottom: 10px; width: 100%; text-align: center; pointer-events: none; }
        button.start-btn { pointer-events: auto; padding: 10px 30px; font-size: 20px; background: #28a745; border: none; color: white; cursor: pointer; border-radius: 5px; display: none; }
        button.start-btn:hover { background: #218838; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div class="hud">
            <div>â¤ï¸ ç”Ÿå‘½: <span id="lives">10</span></div>
            <div>ğŸ’° é‡‘å¹£: <span id="money">100</span></div>
            <div>ğŸŒŠ æ³¢æ•¸: <span id="wave">1</span></div>
        </div>

        <div id="draft-screen">
            <h2 id="draft-title">è¼‰å…¥æ•¸æ“šä¸­...</h2>
            <div id="loading-msg">æ­£åœ¨å¾ Google Sheets è®€å–å¡ç‰Œæ•¸æ“š...</div>
            <div class="cards-container" id="cards-container"></div>
        </div>

        <div id="controls">
            <p>é»æ“Šåœ°åœ–èŠ±è²» 50ğŸ’° å»ºé€ é˜²ç¦¦å¡”</p>
            <button class="start-btn" id="start-wave-btn" onclick="startWave()">é–‹å§‹ä¸‹ä¸€æ³¢</button>
        </div>
    </div>
</div>

<script>
// --- 1. é…ç½®èˆ‡æ•¸æ“šè¼‰å…¥ ---
const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?output=csv';

let loadedUpgrades = [];

// CSV è§£æå™¨
function parseCSV(text) {
    const lines = text.trim().split('\n');
    const headers = lines[0].split(',').map(h => h.trim()); // å‡è¨­ç¬¬ä¸€è¡Œæ˜¯æ¨™é¡Œ
    const data = [];

    for (let i = 1; i < lines.length; i++) {
        const currentline = lines[i].split(',');
        if(currentline.length < headers.length) continue; // è·³éå£è¡Œ
        
        let obj = {};
        for (let j = 0; j < headers.length; j++) {
            obj[headers[j]] = currentline[j] ? currentline[j].trim() : "";
        }
        data.push(obj);
    }
    return data;
}

// æ•¸æ“šæ˜ å°„ï¼šå°‡ CSV çš„æ–‡å­—è½‰æ›ç‚ºéŠæˆ²é‚è¼¯
// è«‹æ ¹æ“šä½ çš„ Google Sheet æ¬„ä½åç¨±ä¿®æ”¹é€™è£¡çš„ key (ä¾‹å¦‚ 'type', 'value')
function mapDataToGameLogic(data) {
    return data.map(item => {
        // é è¨­å€¼ï¼Œé˜²æ­¢ CSV ç¼ºæ¼
        const type = item['type'] || item['Type'] || 'DMG'; 
        const val = parseFloat(item['value'] || item['Value'] || 0);
        const name = item['name'] || item['Name'] || 'æœªçŸ¥å¼·åŒ–';
        const desc = item['description'] || item['desc'] || item['Description'] || 'ç„¡æè¿°';

        return {
            name: name,
            desc: desc,
            apply: () => {
                // æ ¹æ“š type æ±ºå®šæ•ˆæœ
                switch(type.toUpperCase()) {
                    case 'DMG': playerStats.towerDamage += val; break;
                    case 'RNG': playerStats.towerRange += val; break;
                    case 'SPD': playerStats.towerFireRate = Math.max(5, playerStats.towerFireRate - val); break; // æ¸›æ³•åŠ é€Ÿ
                    case 'GOLD': playerStats.goldMultiplier += val; break;
                    case 'HP': updateLives(val); break;
                    default: console.warn('æœªçŸ¥æ•ˆæœé¡å‹:', type);
                }
            }
        };
    });
}

// å•Ÿå‹•æ™‚è¼‰å…¥æ•¸æ“š
async function initGameData() {
    try {
        const response = await fetch(CSV_URL);
        const text = await response.text();
        const rawData = parseCSV(text);
        
        loadedUpgrades = mapDataToGameLogic(rawData);
        
        console.log("æˆåŠŸè¼‰å…¥å¡ç‰Œ:", loadedUpgrades);
        
        // è¼‰å…¥å®Œæˆï¼Œéš±è— Loadingï¼Œé¡¯ç¤ºé–‹å§‹æŒ‰éˆ• (æˆ–ç¬¬ä¸€æ¬¡ Draft)
        document.getElementById('loading-msg').style.display = 'none';
        document.getElementById('draft-title').innerText = "æº–å‚™å°±ç·’";
        document.getElementById('draft-screen').style.display = 'none';
        document.getElementById('start-wave-btn').style.display = 'inline-block';
        
    } catch (e) {
        console.error("è¼‰å…¥å¤±æ•—:", e);
        document.getElementById('loading-msg').innerText = "æ•¸æ“šè¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥æ§åˆ¶å° (F12)";
        document.getElementById('loading-msg').style.color = "red";
        
        // å‚™ç”¨æ•¸æ“šï¼Œé¿å…éŠæˆ²å¡æ­»
        loadedUpgrades = [
            { name: "å‚™ç”¨ç«è—¥", desc: "å‚·å®³+5 (é›¢ç·šæ¨¡å¼)", apply: () => playerStats.towerDamage += 5 },
            { name: "å‚™ç”¨é¡é ­", desc: "ç¯„åœ+20 (é›¢ç·šæ¨¡å¼)", apply: () => playerStats.towerRange += 20 }
        ];
        document.getElementById('start-wave-btn').style.display = 'inline-block';
    }
}

// --- 2. éŠæˆ²æ ¸å¿ƒé‚è¼¯ (éƒ¨åˆ†å¾®èª¿) ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState = {
    lives: 10, money: 100, wave: 1,
    enemies: [], towers: [], projectiles: [], isWaveActive: false
};

let playerStats = {
    towerDamage: 10, towerRange: 100, towerFireRate: 60, goldMultiplier: 1.0
};

const path = [{x: 0, y: 100}, {x: 200, y: 100}, {x: 200, y: 400}, {x: 600, y: 400}, {x: 600, y: 200}, {x: 800, y: 200}];

class Enemy {
    constructor(waveDifficulty) {
        this.pathIndex = 0;
        this.x = path[0].x; this.y = path[0].y;
        this.speed = 1.5 + (waveDifficulty * 0.1);
        this.hp = 20 + (waveDifficulty * 10);
        this.maxHp = this.hp; this.radius = 12; this.active = true;
    }
    update() {
        if (!this.active) return;
        let target = path[this.pathIndex + 1];
        if (!target) { this.active = false; updateLives(-1); return; }
        let dx = target.x - this.x, dy = target.y - this.y, dist = Math.hypot(dx, dy);
        if (dist < this.speed) { this.x = target.x; this.y = target.y; this.pathIndex++; } 
        else { this.x += (dx/dist)*this.speed; this.y += (dy/dist)*this.speed; }
    }
    draw() {
        if (!this.active) return;
        ctx.fillStyle = '#ff4444'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'red'; ctx.fillRect(this.x-10, this.y-20, 20, 4);
        ctx.fillStyle = '#0f0'; ctx.fillRect(this.x-10, this.y-20, 20*(this.hp/this.maxHp), 4);
    }
}

class Tower {
    constructor(x, y) { this.x = x; this.y = y; this.cooldown = 0; }
    update() {
        this.range = playerStats.towerRange;
        if (this.cooldown > 0) this.cooldown--;
        if (this.cooldown <= 0) {
            let target = null, minDist = Infinity;
            gameState.enemies.forEach(e => {
                if (!e.active) return;
                let dist = Math.hypot(e.x - this.x, e.y - this.y);
                if (dist <= this.range && dist < minDist) { minDist = dist; target = e; }
            });
            if (target) {
                gameState.projectiles.push(new Projectile(this.x, this.y, target));
                this.cooldown = playerStats.towerFireRate;
            }
        }
    }
    draw() { ctx.fillStyle = '#4a90e2'; ctx.fillRect(this.x-15, this.y-15, 30, 30); }
}

class Projectile {
    constructor(x, y, target) { this.x = x; this.y = y; this.target = target; this.speed = 8; this.damage = playerStats.towerDamage; this.active = true; }
    update() {
        if (!this.active) return;
        if (!this.target.active) { this.active = false; return; }
        let dx = this.target.x - this.x, dy = this.target.y - this.y, dist = Math.hypot(dx, dy);
        if (dist < this.speed) {
            this.active = false; this.target.hp -= this.damage;
            if (this.target.hp <= 0) { this.target.active = false; updateMoney(Math.floor(10 * playerStats.goldMultiplier)); }
        } else { this.x += (dx/dist)*this.speed; this.y += (dy/dist)*this.speed; }
    }
    draw() { if (!this.active) return; ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill(); }
}

// --- æµç¨‹æ§åˆ¶ ---
function startWave() {
    if (gameState.isWaveActive) return;
    gameState.isWaveActive = true;
    document.getElementById('start-wave-btn').style.display = 'none';
    let enemiesToSpawn = 5 + gameState.wave * 2, spawnedCount = 0;
    const spawner = setInterval(() => {
        if (!gameState.isWaveActive) { clearInterval(spawner); return; }
        gameState.enemies.push(new Enemy(gameState.wave));
        spawnedCount++;
        if (spawnedCount >= enemiesToSpawn) clearInterval(spawner);
    }, 1000);
}

function checkWaveEnd() {
    if (!gameState.isWaveActive) return;
    const activeEnemies = gameState.enemies.some(e => e.active);
    if (!activeEnemies && gameState.enemies.length > 0) {
        setTimeout(() => { if (gameState.isWaveActive) endWave(); }, 1000);
    }
}

function endWave() {
    gameState.isWaveActive = false;
    gameState.enemies = []; gameState.projectiles = [];
    gameState.wave++; document.getElementById('wave').innerText = gameState.wave;
    showDraftScreen();
}

// --- å¡ç‰Œé¸æ“‡ ---
function showDraftScreen() {
    const screen = document.getElementById('draft-screen');
    const container = document.getElementById('cards-container');
    const title = document.getElementById('draft-title');
    
    title.innerText = "é¸æ“‡ä½ çš„å¼·åŒ– (Reward)";
    container.innerHTML = ''; 

    // å¾ loadedUpgrades ä¸­éš¨æ©Ÿé¸
    // å¦‚æœæ•¸æ“šé‚„æ²’è¼‰å…¥å®Œï¼Œä½¿ç”¨ç©ºé™£åˆ—
    const pool = loadedUpgrades.length > 0 ? loadedUpgrades : [];

    if (pool.length === 0) {
        container.innerHTML = "<p>æ²’æœ‰å¯ç”¨çš„å¡ç‰Œæ•¸æ“š</p>";
    } else {
        for (let i = 0; i < 3; i++) {
            const upgrade = pool[Math.floor(Math.random() * pool.length)];
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.desc}</p>`;
            card.onclick = () => selectUpgrade(upgrade);
            container.appendChild(card);
        }
    }
    screen.style.display = 'flex';
}

function selectUpgrade(upgrade) {
    upgrade.apply();
    document.getElementById('draft-screen').style.display = 'none';
    document.getElementById('start-wave-btn').style.display = 'inline-block';
}

// --- è¼¸å…¥èˆ‡å·¥å…· ---
canvas.addEventListener('mousedown', (e) => {
    if (gameState.isWaveActive) return; 
    const rect = canvas.getBoundingClientRect();
    if (gameState.money >= 50) {
        gameState.towers.push(new Tower(e.clientX - rect.left, e.clientY - rect.top));
        updateMoney(-50);
    }
});

function updateMoney(amount) { gameState.money += amount; document.getElementById('money').innerText = gameState.money; }
function updateLives(amount) { 
    gameState.lives += amount; document.getElementById('lives').innerText = gameState.lives;
    if (gameState.lives <= 0) { alert("Game Over!"); location.reload(); }
}

function loop() {
    ctx.fillStyle = '#333'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.strokeStyle = '#555'; ctx.lineWidth = 40; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
    ctx.stroke();

    gameState.towers.forEach(t => { t.update(); t.draw(); });
    gameState.enemies.forEach(e => { e.update(); e.draw(); });
    gameState.projectiles.forEach(p => { p.update(); p.draw(); });

    if (gameState.isWaveActive) checkWaveEnd();
    requestAnimationFrame(loop);
}

// å•Ÿå‹•è³‡æ–™è¼‰å…¥
initGameData();
loop();

</script>
</body>
</html>/**
 * æ ¸å¿ƒé‚è¼¯
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// éŠæˆ²ç‹€æ…‹
let gameState = {
    lives: 10,
    money: 100,
    wave: 1,
    enemies: [],
    towers: [],
    projectiles: [],
    isWaveActive: false,
    frame: 0
};

// å…¨å±€å¼·åŒ–å±¬æ€§ (è‚‰é´¿å…ƒç´ )
let playerStats = {
    towerDamage: 10,
    towerRange: 100,
    towerFireRate: 60, // å¹€æ•¸é–“éš” (è¶Šä½è¶Šå¿«)
    goldMultiplier: 1.0
};

// ç°¡å–®åœ°åœ–è·¯å¾‘ (åº§æ¨™é»)
const path = [
    {x: 0, y: 100}, {x: 200, y: 100}, {x: 200, y: 400}, 
    {x: 600, y: 400}, {x: 600, y: 200}, {x: 800, y: 200}
];

// --- é¡å®šç¾© ---

class Enemy {
    constructor(waveDifficulty) {
        this.pathIndex = 0;
        this.x = path[0].x;
        this.y = path[0].y;
        this.speed = 1.5 + (waveDifficulty * 0.1);
        this.hp = 20 + (waveDifficulty * 10);
        this.maxHp = this.hp;
        this.radius = 12;
        this.active = true;
    }

    update() {
        if (!this.active) return;

        // ç§»å‹•é‚è¼¯
        let target = path[this.pathIndex + 1];
        if (!target) { // åˆ°é”çµ‚é»
            this.active = false;
            updateLives(-1);
            return;
        }

        let dx = target.x - this.x;
        let dy = target.y - this.y;
        let dist = Math.hypot(dx, dy);

        if (dist < this.speed) {
            this.x = target.x;
            this.y = target.y;
            this.pathIndex++;
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }

    draw() {
        if (!this.active) return;
        ctx.fillStyle = '#ff4444';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // è¡€æ¢
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x - 10, this.y - 20, 20, 4);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(this.x - 10, this.y - 20, 20 * (this.hp / this.maxHp), 4);
    }
}

class Tower {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.cooldown = 0;
        this.range = playerStats.towerRange; // ç¹¼æ‰¿å…¨å±€å±¬æ€§
    }

    update() {
        // æ›´æ–°ç•¶å‰å±¬æ€§ (æ‡‰å°å‹•æ…‹å¼·åŒ–)
        this.range = playerStats.towerRange;
        
        if (this.cooldown > 0) this.cooldown--;

        if (this.cooldown <= 0) {
            // å°‹æ‰¾æœ€è¿‘æ•µäºº
            let target = null;
            let minDist = Infinity;

            gameState.enemies.forEach(enemy => {
                if (!enemy.active) return;
                let dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                if (dist <= this.range && dist < minDist) {
                    minDist = dist;
                    target = enemy;
                }
            });

            if (target) {
                this.shoot(target);
                this.cooldown = playerStats.towerFireRate;
            }
        }
    }

    shoot(target) {
        gameState.projectiles.push(new Projectile(this.x, this.y, target));
    }

    draw() {
        ctx.fillStyle = '#4a90e2';
        ctx.fillRect(this.x - 15, this.y - 15, 30, 30);
        
        // æ”»æ“Šç¯„åœ (åƒ…æ»‘é¼ æ‡¸åœæ™‚é¡¯ç¤ºæœƒæ›´å¥½ï¼Œé€™è£¡ç°¡åŒ–è™•ç†ä¸é¡¯ç¤ºæˆ–æ·¡é¡¯ç¤º)
        // ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        // ctx.beginPath();
        // ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
        // ctx.stroke();
    }
}

class Projectile {
    constructor(x, y, target) {
        this.x = x;
        this.y = y;
        this.target = target;
        this.speed = 8;
        this.damage = playerStats.towerDamage;
        this.active = true;
    }

    update() {
        if (!this.active) return;
        if (!this.target.active) {
            this.active = false;
            return;
        }

        let dx = this.target.x - this.x;
        let dy = this.target.y - this.y;
        let dist = Math.hypot(dx, dy);

        if (dist < this.speed) {
            this.active = false;
            this.target.hp -= this.damage;
            if (this.target.hp <= 0) {
                this.target.active = false;
                updateMoney(Math.floor(10 * playerStats.goldMultiplier));
            }
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }

    draw() {
        if (!this.active) return;
        ctx.fillStyle = '#ffeb3b';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fill();
    }
}

// --- éŠæˆ²æµç¨‹æ§åˆ¶ ---

function startWave() {
    if (gameState.isWaveActive) return;
    gameState.isWaveActive = true;
    document.getElementById('start-wave-btn').style.display = 'none';
    
    let enemiesToSpawn = 5 + gameState.wave * 2;
    let spawnInterval = 60; // frames
    let spawnedCount = 0;

    const spawner = setInterval(() => {
        if (!gameState.isWaveActive) { clearInterval(spawner); return; }
        gameState.enemies.push(new Enemy(gameState.wave));
        spawnedCount++;
        if (spawnedCount >= enemiesToSpawn) clearInterval(spawner);
    }, 1000);
}

function checkWaveEnd() {
    if (!gameState.isWaveActive) return;

    // åˆ¤æ–·æ˜¯å¦æ‰€æœ‰æ•µäººéƒ½æ­»å…‰æˆ–è·‘æ‰
    const activeEnemies = gameState.enemies.some(e => e.active);
    // é‚„è¦æª¢æŸ¥æ˜¯å¦é‚„æœ‰å¾…ç”Ÿæˆçš„æ•µäºº? é€™è£¡ç°¡åŒ–ï¼Œå‡è¨­ç”Ÿæˆå™¨è·‘å®Œä¸”å ´ä¸Šç„¡æ€ª
    // ç°¡å–®åˆ¤æ–·ï¼šå¦‚æœå ´ä¸Šæ²’æ€ªäº†ï¼Œä¸”è©²æ³¢æ‡‰è©²ç”Ÿæˆçš„æ•¸é‡éƒ½ç”Ÿæˆäº† (é€™é‡Œç”¨ç°¡å–®é‚è¼¯ï¼šæ•µäººé™£åˆ—é•·åº¦è¶³å¤ ä¸”éƒ½inactive)
    // ç‚ºæ±‚ç©©å®šï¼Œé€™è£¡åªæª¢æŸ¥å ´ä¸Šæ˜¯å¦ç‚ºç©ºï¼Œä¸”ç¢ºä¿å·²éäº†ä¸€å®šæ™‚é–“
    
    if (!activeEnemies && gameState.enemies.length > 0) {
        // ç­‰å­å½ˆé£›ä¸€æœƒå…’
        setTimeout(() => {
            if (gameState.isWaveActive) { // Double check
                endWave();
            }
        }, 1000);
    }
}

function endWave() {
    gameState.isWaveActive = false;
    gameState.enemies = [];
    gameState.projectiles = [];
    gameState.wave++;
    document.getElementById('wave').innerText = gameState.wave;
    showDraftScreen();
}

// --- è‚‰é´¿å¼·åŒ–ç³»çµ± (Draft) ---

const upgrades = [
    { name: "å¼·åŠ›ç«è—¥", desc: "é˜²ç¦¦å¡”å‚·å®³ +5", apply: () => playerStats.towerDamage += 5 },
    { name: "é•·ç®¡æŠ€è¡“", desc: "æ”»æ“Šç¯„åœ +30", apply: () => playerStats.towerRange += 30 },
    { name: "å¿«é€Ÿè£å¡«", desc: "æ”»é€Ÿ +15%", apply: () => playerStats.towerFireRate = Math.max(10, playerStats.towerFireRate * 0.85) },
    { name: "è²ªå©ª", desc: "æ“Šæ®ºé‡‘å¹£ +50%", apply: () => playerStats.goldMultiplier += 0.5 },
    { name: "ç·Šæ€¥ä¿®å¾©", desc: "ç”Ÿå‘½å€¼ +3", apply: () => updateLives(3) }
];

function showDraftScreen() {
    const screen = document.getElementById('draft-screen');
    const container = document.getElementById('cards-container');
    container.innerHTML = ''; // æ¸…ç©ºèˆŠå¡

    // éš¨æ©Ÿé¸3å¼µå¡
    for (let i = 0; i < 3; i++) {
        const upgrade = upgrades[Math.floor(Math.random() * upgrades.length)];
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.desc}</p>`;
        card.onclick = () => selectUpgrade(upgrade);
        container.appendChild(card);
    }
    
    screen.style.display = 'flex';
}

function selectUpgrade(upgrade) {
    upgrade.apply();
    document.getElementById('draft-screen').style.display = 'none';
    document.getElementById('start-wave-btn').style.display = 'inline-block';
}

// --- è¼¸å…¥èˆ‡è¼”åŠ© ---

canvas.addEventListener('mousedown', (e) => {
    if (gameState.isWaveActive) return; // æˆ°é¬¥ä¸­ä¸èƒ½å»ºå¡” (å¯é¸è¦å‰‡)
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (gameState.money >= 50) {
        // ç°¡å–®åˆ¤å®šæ˜¯å¦é»åœ¨è·¯å¾‘ä¸Š (ç¢°æ’æª¢æ¸¬) - é€™è£¡ç•¥éï¼Œç›´æ¥æ”¾
        gameState.towers.push(new Tower(x, y));
        updateMoney(-50);
    }
});

function updateMoney(amount) {
    gameState.money += amount;
    document.getElementById('money').innerText = gameState.money;
}

function updateLives(amount) {
    gameState.lives += amount;
    document.getElementById('lives').innerText = gameState.lives;
    if (gameState.lives <= 0) {
        alert("Game Over! Refresh to restart.");
        location.reload();
    }
}

// --- æ¸²æŸ“å¾ªç’° ---

function loop() {
    // æ¸…ç©ºç•«å¸ƒ
    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // ç•«è·¯å¾‘
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 40;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
    ctx.stroke();

    // æ›´æ–°èˆ‡ç¹ªè£½å¯¦é«”
    gameState.towers.forEach(t => { t.update(); t.draw(); });
    gameState.enemies.forEach(e => { e.update(); e.draw(); });
    gameState.projectiles.forEach(p => { p.update(); p.draw(); });

    // æª¢æŸ¥æ³¢æ¬¡ç‹€æ…‹
    if (gameState.isWaveActive) checkWaveEnd();

    requestAnimationFrame(loop);
}

// å•Ÿå‹•
loop();

</script>
</body>
</html>
