<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Roguelike TD - Level Up Update</title>
    <style>
        body { margin: 0; background: #222; color: #fff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        #game-container { position: relative; display: flex; justify-content: center; margin-top: 20px; }
        canvas { background: #333; border: 2px solid #555; box-shadow: 0 0 20px rgba(0,0,0,0.5); cursor: crosshair; }
        
        #ui-layer { position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 800px; height: 600px; pointer-events: none; }
        .hud { position: absolute; top: 10px; left: 10px; font-size: 18px; font-weight: bold; pointer-events: auto; text-shadow: 1px 1px 2px black; }
        
        /* å‡ç´šèœå–® (æ–°åŠŸèƒ½) */
        #upgrade-menu {
            display: none; position: absolute; background: rgba(20, 20, 30, 0.95); 
            border: 2px solid #00bcd4; padding: 15px; border-radius: 8px; pointer-events: auto;
            flex-direction: column; gap: 10px; min-width: 150px;
            box-shadow: 0 0 15px rgba(0, 188, 212, 0.3);
        }
        #upgrade-menu h4 { margin: 0 0 5px 0; color: #00bcd4; font-size: 16px; }
        #upgrade-menu p { margin: 0; font-size: 12px; color: #aaa; }
        .btn-upgrade { 
            background: #e67e22; border: none; color: white; padding: 8px; cursor: pointer; border-radius: 4px; font-weight: bold;
        }
        .btn-upgrade:hover { background: #d35400; }
        .btn-upgrade:disabled { background: #555; cursor: not-allowed; opacity: 0.6; }
        .btn-close { background: #c0392b; margin-top: 5px; }

        /* è‚‰é´¿å¡ç‰Œé¸æ“‡ç•Œé¢ */
        #draft-screen { 
            display: flex; position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 10;
        }
        #draft-screen h2 { font-size: 32px; color: #ffd700; margin-bottom: 40px; }
        .cards-container { display: flex; gap: 20px; }
        .card { 
            width: 200px; height: 280px; background: #444; border: 2px solid #666; border-radius: 10px; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            cursor: pointer; transition: 0.2s; padding: 20px; text-align: center;
        }
        .card:hover { transform: translateY(-10px); background: #555; border-color: #00bcd4; box-shadow: 0 0 15px #00bcd4; }
        
        #loading-msg { color: #00bcd4; font-size: 24px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        #controls { position: absolute; bottom: 10px; width: 100%; text-align: center; pointer-events: none; }
        button.start-btn { pointer-events: auto; padding: 10px 30px; font-size: 20px; background: #28a745; border: none; color: white; cursor: pointer; border-radius: 5px; display: none; }
        button.start-btn:hover { background: #218838; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div class="hud">
            <div>â¤ï¸ ç”Ÿå‘½: <span id="lives">10</span></div>
            <div>ğŸ’° é‡‘å¹£: <span id="money">150</span></div>
            <div>ğŸŒŠ æ³¢æ•¸: <span id="wave">1</span></div>
        </div>

        <div id="upgrade-menu">
            <h4 id="menu-title">é˜²ç¦¦å¡” Lv.1</h4>
            <p>å‚·å®³: <span id="menu-dmg">0</span> | ç¯„åœ: <span id="menu-rng">0</span></p>
            <button class="btn-upgrade" id="btn-upgrade-action" onclick="upgradeSelectedTower()">
                å‡ç´š (-$100)
            </button>
            <button class="btn-upgrade btn-close" onclick="closeMenu()">é—œé–‰</button>
        </div>

        <div id="draft-screen">
            <h2 id="draft-title">è¼‰å…¥æ•¸æ“šä¸­...</h2>
            <div id="loading-msg">æ­£åœ¨å¾ Google Sheets è®€å–å¡ç‰Œæ•¸æ“š...</div>
            <div class="cards-container" id="cards-container"></div>
        </div>

        <div id="controls">
            <p>é»æ“Šç©ºåœ°èŠ±è²» 50ğŸ’° å»ºé€  | é»æ“Šé˜²ç¦¦å¡”å‡ç´š</p>
            <button class="start-btn" id="start-wave-btn" onclick="startWave()">é–‹å§‹ä¸‹ä¸€æ³¢</button>
        </div>
    </div>
</div>

<script>
// --- 1. é…ç½®èˆ‡æ•¸æ“šè¼‰å…¥ (Google Sheet) ---
const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?output=csv';

let loadedUpgrades = [];

function parseCSV(text) {
    const lines = text.trim().split('\n');
    const headers = lines[0].split(',').map(h => h.trim());
    const data = [];
    for (let i = 1; i < lines.length; i++) {
        const currentline = lines[i].split(',');
        if(currentline.length < headers.length) continue;
        let obj = {};
        for (let j = 0; j < headers.length; j++) obj[headers[j]] = currentline[j] ? currentline[j].trim() : "";
        data.push(obj);
    }
    return data;
}

function mapDataToGameLogic(data) {
    return data.map(item => {
        const type = item['type'] || item['Type'] || 'DMG'; 
        const val = parseFloat(item['value'] || item['Value'] || 0);
        const name = item['name'] || item['Name'] || 'æœªçŸ¥å¼·åŒ–';
        const desc = item['description'] || item['desc'] || item['Description'] || 'ç„¡æè¿°';

        return {
            name: name, desc: desc,
            apply: () => {
                switch(type.toUpperCase()) {
                    case 'DMG': playerStats.globalDamage += val; break; // æ”¹ç‚ºå¢åŠ å…¨å±€è®Šé‡
                    case 'RNG': playerStats.globalRange += val; break;
                    case 'SPD': playerStats.globalFireRate = Math.max(5, playerStats.globalFireRate - val); break;
                    case 'GOLD': playerStats.goldMultiplier += val; break;
                    case 'HP': updateLives(val); break;
                }
            }
        };
    });
}

async function initGameData() {
    try {
        const response = await fetch(CSV_URL);
        const text = await response.text();
        loadedUpgrades = mapDataToGameLogic(parseCSV(text));
        document.getElementById('loading-msg').style.display = 'none';
        document.getElementById('draft-title').innerText = "æº–å‚™å°±ç·’";
        document.getElementById('draft-screen').style.display = 'none';
        document.getElementById('start-wave-btn').style.display = 'inline-block';
    } catch (e) {
        console.error("è¼‰å…¥å¤±æ•—", e);
        loadedUpgrades = [{ name: "å‚™ç”¨ç«è—¥", desc: "å‚·å®³+5", apply: () => playerStats.globalDamage += 5 }];
        document.getElementById('loading-msg').style.display = 'none';
        document.getElementById('draft-screen').style.display = 'none';
        document.getElementById('start-wave-btn').style.display = 'inline-block';
    }
}

// --- 2. éŠæˆ²æ ¸å¿ƒè®Šæ•¸èª¿æ•´ ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState = {
    lives: 10,
    money: 150, // å¢åŠ åˆå§‹é‡‘å¹£ï¼Œé¿å…ç¬¬ä¸€æ³¢å¡æ­»
    wave: 1,
    enemies: [],
    towers: [],
    projectiles: [],
    isWaveActive: false
};

// å…¨å±€å±¬æ€§ (ä¾†è‡ªå¡ç‰Œ) + å¡”çš„åŸºç¤å±¬æ€§åˆ†é›¢
let playerStats = {
    globalDamage: 0,      // å¡ç‰Œçµ¦çš„é¡å¤–å‚·å®³
    globalRange: 0,       // å¡ç‰Œçµ¦çš„é¡å¤–ç¯„åœ
    globalFireRate: 60,   // åŸºç¤å°„é€Ÿ
    goldMultiplier: 1.0,
    baseDamage: 15        // æé«˜åŸºç¤å‚·å®³ (åŸæœ¬10)
};

const path = [{x: 0, y: 100}, {x: 200, y: 100}, {x: 200, y: 400}, {x: 600, y: 400}, {x: 600, y: 200}, {x: 800, y: 200}];

// --- 3. é¡å®šç¾© (æ–°å¢ç­‰ç´šèˆ‡å‡ç´šé‚è¼¯) ---

class Tower {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.cooldown = 0;
        this.level = 1;
        this.baseRange = 100;
        this.levelDamageBonus = 0;
        this.levelRangeBonus = 0;
    }

    getDamage() {
        // å‚·å®³ = åŸºç¤(15) + å¡ç‰ŒåŠ æˆ + ç­‰ç´šåŠ æˆ
        return playerStats.baseDamage + playerStats.globalDamage + this.levelDamageBonus;
    }

    getRange() {
        return this.baseRange + playerStats.globalRange + this.levelRangeBonus;
    }

    upgrade() {
        this.level++;
        this.levelDamageBonus += 10; // æ¯æ¬¡å‡ç´šåŠ  10 é»å‚·å®³
        this.levelRangeBonus += 20;  // æ¯æ¬¡å‡ç´šåŠ  20 é»ç¯„åœ
    }

    update() {
        if (this.cooldown > 0) this.cooldown--;
        if (this.cooldown <= 0) {
            let target = null, minDist = Infinity;
            let currentRange = this.getRange();
            gameState.enemies.forEach(e => {
                if (!e.active) return;
                let dist = Math.hypot(e.x - this.x, e.y - this.y);
                if (dist <= currentRange && dist < minDist) { minDist = dist; target = e; }
            });
            if (target) {
                gameState.projectiles.push(new Projectile(this.x, this.y, target, this.getDamage()));
                this.cooldown = playerStats.globalFireRate;
            }
        }
    }

    draw() {
        // æ ¹æ“šç­‰ç´šæ”¹è®Šé¡è‰²
        if (this.level === 1) ctx.fillStyle = '#4a90e2'; // è—
        else if (this.level === 2) ctx.fillStyle = '#9b59b6'; // ç´«
        else ctx.fillStyle = '#f1c40f'; // é‡‘

        ctx.fillRect(this.x-15, this.y-15, 30, 30);
        
        // ç•«ç­‰ç´šæ¨™è¨˜
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.fillText("Lv." + this.level, this.x - 10, this.y - 20);

        // å¦‚æœæ˜¯è¢«é¸ä¸­çš„å¡”ï¼Œç•«å€‹åœˆ
        if (selectedTower === this) {
            ctx.strokeStyle = '#00bcd4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.getRange(), 0, Math.PI*2);
            ctx.stroke();
        }
    }
}

class Enemy {
    constructor(waveDifficulty) {
        this.pathIndex = 0;
        this.x = path[0].x; this.y = path[0].y;
        this.speed = 1.5 + (waveDifficulty * 0.1);
        this.hp = 20 + (waveDifficulty * 10);
        this.maxHp = this.hp; this.radius = 12; this.active = true;
    }
    update() {
        if (!this.active) return;
        let target = path[this.pathIndex + 1];
        if (!target) { this.active = false; updateLives(-1); return; }
        let dx = target.x - this.x, dy = target.y - this.y, dist = Math.hypot(dx, dy);
        if (dist < this.speed) { this.x = target.x; this.y = target.y; this.pathIndex++; } 
        else { this.x += (dx/dist)*this.speed; this.y += (dy/dist)*this.speed; }
    }
    draw() {
        if (!this.active) return;
        ctx.fillStyle = '#ff4444'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'red'; ctx.fillRect(this.x-10, this.y-20, 20, 4);
        ctx.fillStyle = '#0f0'; ctx.fillRect(this.x-10, this.y-20, 20*(this.hp/this.maxHp), 4);
    }
}

class Projectile {
    constructor(x, y, target, damage) { 
        this.x = x; this.y = y; this.target = target; 
        this.speed = 8; this.damage = damage; this.active = true; 
    }
    update() {
        if (!this.active) return;
        if (!this.target.active) { this.active = false; return; }
        let dx = this.target.x - this.x, dy = this.target.y - this.y, dist = Math.hypot(dx, dy);
        if (dist < this.speed) {
            this.active = false; this.target.hp -= this.damage;
            if (this.target.hp <= 0) { this.target.active = false; updateMoney(Math.floor(10 * playerStats.goldMultiplier)); }
        } else { this.x += (dx/dist)*this.speed; this.y += (dy/dist)*this.speed; }
    }
    draw() { if (!this.active) return; ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill(); }
}

// --- 4. äº’å‹•é‚è¼¯ (å»ºé€ èˆ‡å‡ç´š) ---

let selectedTower = null;
const upgradeMenu = document.getElementById('upgrade-menu');

canvas.addEventListener('mousedown', (e) => {
    // ç²å–æ»‘é¼ åº§æ¨™
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // 1. æª¢æŸ¥æ˜¯å¦é»æ“Šäº†ç¾æœ‰çš„å¡” (å‡ç´šæ¨¡å¼)
    const clickedTower = gameState.towers.find(t => Math.hypot(t.x - x, t.y - y) < 20);

    if (clickedTower) {
        openUpgradeMenu(clickedTower, e.clientX, e.clientY);
    } else {
        // 2. å¦‚æœé»ç©ºåœ°ï¼Œå»ºé€ æ–°å¡”
        closeMenu(); // é—œé–‰èˆŠèœå–®
        if (gameState.money >= 50) {
            // ç°¡å–®çš„é‡ç–Šæª¢æŸ¥
            const overlap = gameState.towers.some(t => Math.hypot(t.x - x, t.y - y) < 30);
            if (!overlap) {
                gameState.towers.push(new Tower(x, y));
                updateMoney(-50);
            }
        }
    }
});

function openUpgradeMenu(tower, screenX, screenY) {
    selectedTower = tower;
    
    // è¨ˆç®—å‡ç´šè²»ç”¨ (ç­‰ç´š * 100)
    const cost = tower.level * 100;
    
    document.getElementById('menu-title').innerText = `é˜²ç¦¦å¡” Lv.${tower.level}`;
    document.getElementById('menu-dmg').innerText = Math.floor(tower.getDamage());
    document.getElementById('menu-rng').innerText = Math.floor(tower.getRange());
    
    const btn = document.getElementById('btn-upgrade-action');
    btn.innerText = `å‡ç´š (-$${cost})`;
    btn.onclick = upgradeSelectedTower; // é‡æ–°ç¶å®šäº‹ä»¶
    
    // å¦‚æœéŒ¢ä¸å¤ ï¼ŒæŒ‰éˆ•è®Šç°
    btn.disabled = gameState.money < cost;

    // é¡¯ç¤ºèœå–®
    upgradeMenu.style.left = (screenX + 20) + 'px';
    upgradeMenu.style.top = (screenY - 50) + 'px';
    upgradeMenu.style.display = 'flex';
}

function upgradeSelectedTower() {
    if (!selectedTower) return;
    const cost = selectedTower.level * 100;
    
    if (gameState.money >= cost) {
        updateMoney(-cost);
        selectedTower.upgrade();
        closeMenu(); // å‡ç´šå®Œé—œé–‰èœå–®
    }
}

function closeMenu() {
    selectedTower = null;
    upgradeMenu.style.display = 'none';
}

// --- 5. æµç¨‹æ§åˆ¶ ---

function startWave() {
    if (gameState.isWaveActive) return;
    gameState.isWaveActive = true;
    document.getElementById('start-wave-btn').style.display = 'none';
    closeMenu(); // é–‹å§‹æ³¢æ¬¡æ™‚é—œé–‰èœå–®
    
    let enemiesToSpawn = 5 + gameState.wave * 2;
    let spawnInterval = 60;
    let spawnedCount = 0;

    const spawner = setInterval(() => {
        if (!gameState.isWaveActive) { clearInterval(spawner); return; }
        gameState.enemies.push(new Enemy(gameState.wave));
        spawnedCount++;
        if (spawnedCount >= enemiesToSpawn) clearInterval(spawner);
    }, 1000);
}

function checkWaveEnd() {
    if (!gameState.isWaveActive) return;
    const activeEnemies = gameState.enemies.some(e => e.active);
    if (!activeEnemies && gameState.enemies.length > 0) {
        setTimeout(() => { if (gameState.isWaveActive) endWave(); }, 1000);
    }
}

function endWave() {
    gameState.isWaveActive = false;
    gameState.enemies = []; gameState.projectiles = [];
    gameState.wave++; document.getElementById('wave').innerText = gameState.wave;
    showDraftScreen();
}

function showDraftScreen() {
    const screen = document.getElementById('draft-screen');
    const container = document.getElementById('cards-container');
    container.innerHTML = ''; 
    const pool = loadedUpgrades.length > 0 ? loadedUpgrades : [];

    if (pool.length === 0) container.innerHTML = "<p>ç„¡æ•¸æ“š</p>";
    else {
        for (let i = 0; i < 3; i++) {
            const upgrade = pool[Math.floor(Math.random() * pool.length)];
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.desc}</p>`;
            card.onclick = () => selectUpgrade(upgrade);
            container.appendChild(card);
        }
    }
    screen.style.display = 'flex';
}

function selectUpgrade(upgrade) {
    upgrade.apply();
    document.getElementById('draft-screen').style.display = 'none';
    document.getElementById('start-wave-btn').style.display = 'inline-block';
}

function updateMoney(amount) { 
    gameState.money += amount; 
    document.getElementById('money').innerText = gameState.money; 
    
    // å¦‚æœèœå–®é–‹è‘—ï¼Œå³æ™‚æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
    if(selectedTower) {
        const cost = selectedTower.level * 100;
        document.getElementById('btn-upgrade-action').disabled = gameState.money < cost;
    }
}

function updateLives(amount) { 
    gameState.lives += amount; document.getElementById('lives').innerText = gameState.lives;
    if (gameState.lives <= 0) { alert("Game Over!"); location.reload(); }
}

function loop() {
    ctx.fillStyle = '#333'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.strokeStyle = '#555'; ctx.lineWidth = 40; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
    ctx.stroke();

    gameState.towers.forEach(t => { t.update(); t.draw(); });
    gameState.enemies.forEach(e => { e.update(); e.draw(); });
    gameState.projectiles.forEach(p => { p.update(); p.draw(); });

    if (gameState.isWaveActive) checkWaveEnd();
    requestAnimationFrame(loop);
}

initGameData();
loop();

</script>
</body>
</html>
