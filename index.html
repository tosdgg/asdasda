<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Roguelike TD V9.0 - Tags & Preview</title>
    <style>
        body { margin: 0; background: #222; color: #fff; font-family: 'Microsoft JhengHei', sans-serif; overflow: hidden; }
        #game-container { position: relative; display: flex; justify-content: center; margin-top: 20px; }
        canvas { background: #333; border: 2px solid #555; cursor: crosshair; }
        
        #ui-layer { position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 800px; height: 600px; pointer-events: none; }
        .hud { position: absolute; top: 10px; left: 10px; font-size: 18px; font-weight: bold; pointer-events: auto; text-shadow: 1px 1px 2px black; }
        
        #upgrade-menu {
            display: none; position: absolute; background: rgba(20, 20, 30, 0.95); 
            border: 2px solid #00bcd4; padding: 15px; border-radius: 8px; pointer-events: auto;
            flex-direction: column; gap: 8px; min-width: 180px; z-index: 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #upgrade-menu h4 { margin: 0 0 5px 0; color: #00bcd4; border-bottom: 1px solid #444; padding-bottom: 5px; }
        
        .stat-row { display: flex; justify-content: space-between; font-size: 13px; color: #ccc; margin-bottom: 2px; }
        .stat-val { color: #fff; font-weight: bold; }
        .stat-val.highlight { color: #f1c40f; }

        .btn-group { display: flex; gap: 5px; margin-top: 5px; }
        .btn-upgrade { background: #e67e22; border: none; color: white; padding: 8px; cursor: pointer; border-radius: 4px; flex: 1; font-weight: bold;}
        .btn-upgrade:disabled { background: #555; cursor: not-allowed; opacity: 0.7; }
        .btn-sell { background: #c0392b; border: none; color: white; padding: 8px; cursor: pointer; border-radius: 4px; flex: 1; font-weight: bold;}
        .btn-close { background: #555; width: 100%; margin-top: 5px; border: none; padding: 5px; color: #aaa; cursor: pointer; border-radius: 4px; }

        #draft-screen { 
            display: flex; position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 10;
        }
        .cards-container { display: flex; gap: 20px; }
        .card { 
            width: 200px; height: 280px; background: #444; border: 2px solid #666; border-radius: 10px; 
            padding: 20px; cursor: pointer; text-align: center; display: flex; flex-direction: column; justify-content: center;
        }
        .card:hover { transform: translateY(-10px); border-color: #00bcd4; background: #555; }
        
        #loading-msg { color: #00bcd4; font-size: 24px; }
        #controls { position: absolute; bottom: 10px; width: 100%; text-align: center; pointer-events: none; }
        button.start-btn { pointer-events: auto; padding: 10px 30px; font-size: 20px; background: #28a745; border: none; color: white; cursor: pointer; border-radius: 5px; display: none; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div class="hud">
            <div>‚ù§Ô∏è ÁîüÂëΩ: <span id="lives">20</span></div>
            <div>üí∞ ÈáëÂπ£: <span id="money">200</span></div>
            <div>üåä Ê≥¢Êï∏: <span id="wave">1</span></div>
            <div style="font-size: 14px; color: #aaa; margin-top: 5px;">Êïµ‰∫∫Êï∏Èáè: <span id="enemy-count">0</span></div>
        </div>

        <div id="upgrade-menu">
            <h4 id="menu-title">Èò≤Á¶¶Â°î Lv.1</h4>
            <div class="stat-row"><span>‚öîÔ∏è ÊîªÊìäÂäõ:</span> <span class="stat-val" id="menu-dmg">0</span></div>
            <div class="stat-row"><span>üéØ ÁØÑÂúç:</span> <span class="stat-val" id="menu-rng">0</span></div>
            <div class="stat-row"><span>‚ö° ÊîªÈÄü:</span> <span class="stat-val highlight" id="menu-spd">0/s</span></div>
            <div class="btn-group"><button class="btn-upgrade" id="btn-upgrade-action" onclick="upgradeSelectedTower()">ÂçáÁ¥ö</button></div>
            <div class="btn-group"><button class="btn-sell" id="btn-sell-action" onclick="sellSelectedTower()">Âá∫ÂîÆ</button></div>
            <button class="btn-close" onclick="closeMenu()">ÈóúÈñâÈÅ∏ÂñÆ</button>
        </div>

        <div id="draft-screen">
            <h2 id="draft-title">ËÆÄÂèñ Google Sheets...</h2>
            <div id="loading-msg">Ë´ãÁ®çÂÄô...</div>
            <div class="cards-container" id="cards-container"></div>
        </div>

        <div id="controls">
            <p>ÁßªÂãïÊªëÈº†È†êË¶ΩÂª∫ÈÄ† ($50) | ÈªûÊìäÈò≤Á¶¶Â°îÊü•ÁúãË©≥ÊÉÖ</p>
            <button class="start-btn" id="start-wave-btn" onclick="startWave()">‰∏ã‰∏ÄÊ≥¢ (Next Wave)</button>
        </div>
    </div>
</div>

<script>
// --- 1. Ë®≠ÁΩÆËàá Tag Ëß£ÊûêÂô® ---
const UPGRADE_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?output=csv';
const ENEMY_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?gid=754158994&output=csv';

let loadedUpgrades = [];
let loadedEnemyTypes = [];
let specialStats = { slowFactor: 0, splashRadius: 0 };
let mousePos = { x: -100, y: -100 }; // ËøΩËπ§ÊªëÈº†‰ΩçÁΩÆ

function parseCSV(text) {
    const lines = text.trim().split('\n');
    const headers = lines[0].split(',').map(h => h.trim());
    const data = [];
    for (let i = 1; i < lines.length; i++) {
        const currentline = lines[i].split(',');
        if(currentline.length < headers.length) continue;
        let obj = {};
        for (let j = 0; j < headers.length; j++) obj[headers[j]] = currentline[j] ? currentline[j].trim() : "";
        data.push(obj);
    }
    return data;
}

// --- V9.0 Êñ∞Â¢û: Tag Ëß£ÊûêÈÇèËºØ ---
function applyTags(tagString) {
    if (!tagString) return;
    
    // Ê≠£ÂâáË°®ÈÅîÂºèÔºöÂ∞ãÊâæ #codeÊï∏ÂÄº (‰æãÂ¶Ç #dmg50, #rag-30)
    // ÊîØÊè¥Â∞èÊï∏ÈªûÔºåÊîØÊè¥Ë≤†Ëôü
    const regex = /#([a-zA-Z]+)([-]?\d+(\.\d+)?)/g;
    let match;

    while ((match = regex.exec(tagString)) !== null) {
        const code = match[1].toLowerCase(); // ‰ª£Á¢º (Â¶Ç dmg)
        const val = parseFloat(match[2]);    // Êï∏ÂÄº (Â¶Ç 50, -30)

        switch(code) {
            case 'dmg': playerStats.globalDamage += val; break;
            case 'rng': // ÂÖºÂÆπÂÖ©Á®ÆÂØ´Ê≥ï
            case 'rag': playerStats.globalRange += val; break;
            case 'spd': playerStats.globalFireRate = Math.max(5, playerStats.globalFireRate - val); break; // Ê≥®ÊÑèÔºöÈÄôË£°valÊòØÊ∏õÂ∞ëÁöÑÂÜ∑ÂçªÂπÄ
            case 'coin': // ÂÖºÂÆπ gold/coin
            case 'gold': playerStats.goldMultiplier += (val / 100); break; // ÂÅáË®≠Ëº∏ÂÖ•50‰ª£Ë°®50%
            case 'hp': updateLives(val); break;
            case 'ice': specialStats.slowFactor = Math.min(0.8, specialStats.slowFactor + (val/100)); break;
            case 'aoe': specialStats.splashRadius += val; break;
        }
    }
}

function mapUpgrades(data) {
    return data.map(item => {
        // ÂÑ™ÂÖàËÆÄÂèñ 'tags' Ê¨Ñ‰ΩçÔºåÂ¶ÇÊûúÊ≤íÊúâÂâá‰ΩøÁî®ËàäÈÇèËºØ
        const tags = item['tags'] || item['Tags'];
        
        // ËàäÈÇèËºØÂÖºÂÆπ (Type/Value)
        const type = (item['type'] || item['Type'] || '').toUpperCase();
        const val = parseFloat(item['value'] || item['Value'] || 0);

        return {
            name: item['name'] || 'Êú™Áü•', 
            desc: item['description'] || '',
            apply: () => {
                // Â¶ÇÊûúÊúâ TagsÔºåÂÑ™ÂÖàËß£Êûê Tags
                if (tags && tags.length > 0) {
                    applyTags(tags);
                } else if (type) {
                    // ËàäÁ≥ªÁµ±ÂõûÈÄÄ
                    let tagStr = "";
                    if(type === 'DMG') tagStr = `#dmg${val}`;
                    else if(type === 'RNG') tagStr = `#rng${val}`;
                    else if(type === 'SPD') tagStr = `#spd${val}`;
                    else if(type === 'GOLD') tagStr = `#gold${val*100}`; // ËàäÁ≥ªÁµ±ÊòØÂ∞èÊï∏ÔºåËΩâÊàêÁôæÂàÜÊØî
                    else if(type === 'HP') tagStr = `#hp${val}`;
                    applyTags(tagStr);
                }
            }
        };
    });
}

function mapEnemies(data) {
    return data.filter(item => item['name']).map(item => ({
        name: item['name'],
        baseHp: parseFloat(item['hp'] || 50) || 50,
        speed: parseFloat(item['speed'] || 1.5) || 1.5,
        gold: parseFloat(item['gold'] || 15) || 15,
        weight: parseFloat(item['weight'] || 10) || 10
    }));
}

function getRandomEnemyType() {
    if (!loadedEnemyTypes || loadedEnemyTypes.length === 0) return { name: "BUGÂè≤ËêäÂßÜ", baseHp: 50, speed: 1.0, gold: 10, weight: 1 };
    const totalWeight = loadedEnemyTypes.reduce((sum, type) => sum + type.weight, 0);
    let random = Math.random() * totalWeight;
    for (const type of loadedEnemyTypes) {
        if (random < type.weight) return type;
        random -= type.weight;
    }
    return loadedEnemyTypes[0];
}

async function initGameData() {
    try {
        const [uRes, eRes] = await Promise.all([fetch(UPGRADE_CSV_URL), fetch(ENEMY_CSV_URL)]);
        loadedUpgrades = mapUpgrades(parseCSV(await uRes.text()));
        loadedEnemyTypes = mapEnemies(parseCSV(await eRes.text()));
        if(loadedEnemyTypes.length === 0) throw new Error("CSVÁ©∫");
        startGameUI();
    } catch (e) {
        console.error("ËºâÂÖ•Â§±Êïó:", e);
        loadedEnemyTypes = [{ name: "È†êË®≠ÊÄ™", baseHp: 50, speed: 1.5, gold: 10, weight: 100 }];
        loadedUpgrades = [{ name: "Ê∏¨Ë©¶Âç°", desc: "ÂÇ∑ÂÆ≥+5", apply:()=>playerStats.globalDamage+=5 }];
        startGameUI();
    }
}

function startGameUI() {
    document.getElementById('loading-msg').style.display = 'none';
    document.getElementById('draft-screen').style.display = 'none';
    document.getElementById('start-wave-btn').style.display = 'inline-block';
}

// --- 2. ÈÅäÊà≤Ê†∏ÂøÉ ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameState = { lives: 20, money: 200, wave: 1, enemies: [], towers: [], projectiles: [], isWaveActive: false, isEndingWave: false };
let playerStats = { globalDamage: 0, globalRange: 0, globalFireRate: 60, goldMultiplier: 1.0, baseDamage: 15 };
const path = [{x: 0, y: 100}, {x: 200, y: 100}, {x: 200, y: 400}, {x: 600, y: 400}, {x: 600, y: 200}, {x: 800, y: 200}];

class Enemy {
    constructor(wave) {
        const type = getRandomEnemyType();
        this.name = type.name; this.goldReward = type.gold;
        this.pathIndex = 0; this.x = path[0].x; this.y = path[0].y;
        this.baseSpeed = type.speed; this.currentSpeed = this.baseSpeed;
        const scaleMultiplier = Math.pow(1.2, wave - 1);
        this.hp = Math.floor(type.baseHp * scaleMultiplier);
        this.maxHp = this.hp;
        this.slowTimer = 0; this.active = true;
    }
    update() {
        if (!this.active) return;
        if (this.slowTimer > 0) { this.slowTimer--; this.currentSpeed = this.baseSpeed * (1 - specialStats.slowFactor); }
        else { this.currentSpeed = this.baseSpeed; }
        let target = path[this.pathIndex + 1];
        if (!target) { this.active = false; updateLives(-1); return; }
        let dx = target.x - this.x, dy = target.y - this.y, dist = Math.hypot(dx, dy);
        if (dist < this.currentSpeed) { this.x = target.x; this.y = target.y; this.pathIndex++; } 
        else { this.x += (dx/dist)*this.currentSpeed; this.y += (dy/dist)*this.currentSpeed; }
    }
    takeDamage(dmg) {
        this.hp -= dmg;
        if (this.hp <= 0 && this.active) {
            this.active = false;
            updateMoney(Math.floor(this.goldReward * playerStats.goldMultiplier));
        }
    }
    draw() {
        if (!this.active) return;
        ctx.fillStyle = this.slowTimer > 0 ? '#00bfff' : 'white';
        ctx.font = "bold 16px Arial"; ctx.textAlign = "center";
        ctx.strokeStyle = "black"; ctx.lineWidth = 3;
        ctx.strokeText(this.name, this.x, this.y); ctx.fillText(this.name, this.x, this.y);
        ctx.fillStyle = "red"; ctx.fillRect(this.x-20, this.y-15, 40, 4);
        ctx.fillStyle = "#00ff00"; ctx.fillRect(this.x-20, this.y-15, 40 * (this.hp/this.maxHp), 4);
    }
}

class Tower {
    constructor(x, y) { 
        this.x = x; this.y = y; this.cooldown = 0; this.level = 1; 
        this.baseRange = 100; this.levelDamage = 0; this.levelRange = 0;
        this.totalCost = 50; 
    }
    getDamage() { return playerStats.baseDamage + playerStats.globalDamage + this.levelDamage; }
    getRange() { return this.baseRange + playerStats.globalRange + this.levelRange; }
    getAttacksPerSecond() { return (60 / playerStats.globalFireRate).toFixed(2); }
    upgrade() { this.level++; this.levelDamage += 15; this.levelRange += 15; this.totalCost += (this.level - 1) * 150; }
    update() {
        if (this.cooldown > 0) this.cooldown--;
        if (this.cooldown <= 0) {
            let target = null, minDist = Infinity, range = this.getRange();
            gameState.enemies.forEach(e => {
                if (!e.active) return;
                let dist = Math.hypot(e.x - this.x, e.y - this.y);
                if (dist <= range && dist < minDist) { minDist = dist; target = e; }
            });
            if (target) {
                gameState.projectiles.push(new Projectile(this.x, this.y, target, this.getDamage()));
                this.cooldown = playerStats.globalFireRate;
            }
        }
    }
    draw() {
        ctx.fillStyle = this.level === 1 ? '#4a90e2' : (this.level === 2 ? '#9b59b6' : '#f1c40f');
        ctx.fillRect(this.x-15, this.y-15, 30, 30);
        if (specialStats.splashRadius > 0) { ctx.strokeStyle = 'rgba(255, 68, 68, 0.5)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(this.x,this.y,20,0,Math.PI*2); ctx.stroke(); }
        if (specialStats.slowFactor > 0) { ctx.strokeStyle = 'rgba(0, 191, 255, 0.5)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(this.x,this.y,25,0,Math.PI*2); ctx.stroke(); }
        ctx.fillStyle = '#fff'; ctx.font = '12px Arial'; ctx.fillText("Lv."+this.level, this.x-10, this.y-20);
        if(selectedTower === this) { ctx.strokeStyle='#00bcd4'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(this.x,this.y,this.getRange(),0,Math.PI*2); ctx.stroke(); }
    }
}

class Projectile {
    constructor(x, y, target, damage) { this.x = x; this.y = y; this.target = target; this.speed = 10; this.damage = damage; this.active = true; }
    update() {
        if (!this.active) return;
        if (!this.target.active) { this.active = false; return; }
        let dx = this.target.x - this.x, dy = this.target.y - this.y, dist = Math.hypot(dx, dy);
        if (dist < this.speed) { this.hit(this.target); } else { this.x += (dx/dist)*this.speed; this.y += (dy/dist)*this.speed; }
    }
    hit(target) {
        this.active = false; target.takeDamage(this.damage);
        if (specialStats.slowFactor > 0 && target.active) target.slowTimer = 60;
        if (specialStats.splashRadius > 0) {
            gameState.enemies.forEach(e => {
                if (e === target || !e.active) return;
                if (Math.hypot(e.x - this.x, e.y - this.y) <= specialStats.splashRadius) e.takeDamage(this.damage * 0.5);
            });
        }
    }
    draw() { if (!this.active) return; ctx.fillStyle = specialStats.slowFactor > 0 ? '#00bfff' : '#ffeb3b'; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill(); }
}

// --- UI & Control ---
let selectedTower = null; const upgradeMenu = document.getElementById('upgrade-menu');

// ËøΩËπ§ÊªëÈº†‰ΩçÁΩÆ (ÁÇ∫‰∫ÜÈ†êË¶ΩÂäüËÉΩ)
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mousePos.x = e.clientX - rect.left;
    mousePos.y = e.clientY - rect.top;
});

canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect(), x = e.clientX - rect.left, y = e.clientY - rect.top;
    const clicked = gameState.towers.find(t => Math.hypot(t.x-x, t.y-y) < 25);
    
    if (clicked) {
        openUpgradeMenu(clicked, e.clientX, e.clientY);
    } else {
        closeMenu();
        if (gameState.money >= 50 && !gameState.towers.some(t => Math.hypot(t.x-x, t.y-y) < 30)) { 
            gameState.towers.push(new Tower(x, y)); 
            updateMoney(-50); 
        }
    }
});

// V9.0: Áπ™Ë£ΩÂª∫ÈÄ†È†êË¶Ω
function drawBuildPreview() {
    // Â¶ÇÊûúÈå¢‰∏çÂ§†ÔºåÊàñËÄÖÊªëÈº†Âú®ÈÅ∏ÂñÆ‰∏äÔºåÂ∞±‰∏çÁï´
    if (gameState.money < 50 || selectedTower) return;

    // Ê™¢Êü•ÊòØÂê¶ÈáçÁñä
    const overlap = gameState.towers.some(t => Math.hypot(t.x - mousePos.x, t.y - mousePos.y) < 30);
    
    ctx.globalAlpha = 0.5; // ÂçäÈÄèÊòé
    
    // È†êË¶ΩÂ°îË∫´
    ctx.fillStyle = overlap ? '#ff4444' : '#4a90e2'; // Á¥ÖËâ≤=‰∏çÂèØÂª∫, ËóçËâ≤=ÂèØÂª∫
    ctx.fillRect(mousePos.x - 15, mousePos.y - 15, 30, 30);
    
    // È†êË¶ΩÁØÑÂúç
    ctx.beginPath();
    ctx.arc(mousePos.x, mousePos.y, 100 + playerStats.globalRange, 0, Math.PI*2);
    ctx.fillStyle = overlap ? 'rgba(255,0,0,0.1)' : 'rgba(74, 144, 226, 0.2)';
    ctx.fill();
    ctx.strokeStyle = overlap ? 'red' : '#4a90e2';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    ctx.globalAlpha = 1.0; // ÊÅ¢Âæ©‰∏çÈÄèÊòé
}

function openUpgradeMenu(tower, mouseX, mouseY) {
    selectedTower = tower;
    const cost = tower.level * 150;
    const sellPrice = Math.floor(tower.totalCost * 0.7);

    document.getElementById('menu-title').innerText = `Èò≤Á¶¶Â°î Lv.${tower.level}`;
    document.getElementById('menu-dmg').innerText = Math.floor(tower.getDamage());
    document.getElementById('menu-rng').innerText = Math.floor(tower.getRange());
    document.getElementById('menu-spd').innerText = tower.getAttacksPerSecond() + " Áôº/Áßí";

    const btnUpgrade = document.getElementById('btn-upgrade-action');
    btnUpgrade.innerText = `ÂçáÁ¥ö (-$${cost})`;
    btnUpgrade.onclick = () => { if (gameState.money >= cost) { updateMoney(-cost); selectedTower.upgrade(); closeMenu(); } };
    btnUpgrade.disabled = gameState.money < cost;

    const btnSell = document.getElementById('btn-sell-action');
    btnSell.innerText = `Âá∫ÂîÆ (+$${sellPrice})`;
    
    upgradeMenu.style.left = (mouseX + 10) + 'px'; 
    upgradeMenu.style.top = (mouseY - 80) + 'px';
    upgradeMenu.style.display = 'flex';
}

function sellSelectedTower() {
    if (!selectedTower) return;
    updateMoney(Math.floor(selectedTower.totalCost * 0.7));
    gameState.towers = gameState.towers.filter(t => t !== selectedTower);
    closeMenu();
}

function closeMenu() { selectedTower = null; upgradeMenu.style.display = 'none'; }
function updateMoney(v) { gameState.money += v; document.getElementById('money').innerText = gameState.money; }
function updateLives(v) { gameState.lives += v; document.getElementById('lives').innerText = gameState.lives; if(gameState.lives<=0) { alert("ÊïóÂåóÔºÅ"); location.reload(); } }

function startWave() {
    if (gameState.isWaveActive) return;
    gameState.isWaveActive = true; gameState.isEndingWave = false; 
    document.getElementById('start-wave-btn').style.display = 'none'; closeMenu();
    let max = 5 + (gameState.wave * 3); 
    let interval = Math.max(200, 800 - (gameState.wave * 20));
    document.getElementById('enemy-count').innerText = max;
    let count = 0;
    const spawner = setInterval(() => {
        if(!gameState.isWaveActive) { clearInterval(spawner); return; }
        try { gameState.enemies.push(new Enemy(gameState.wave)); } catch(e) {}
        count++; if(count >= max) clearInterval(spawner);
    }, interval);
}

function endWave() {
    gameState.isWaveActive = false; gameState.enemies = []; gameState.projectiles = [];
    gameState.wave++; document.getElementById('wave').innerText = gameState.wave;
    showDraft();
}
function showDraft() {
    const box = document.getElementById('cards-container'); box.innerHTML = '';
    const pool = loadedUpgrades.length ? loadedUpgrades : [];
    for(let i=0; i<3; i++) {
        const u = pool[Math.floor(Math.random()*pool.length)];
        const d = document.createElement('div'); d.className='card';
        d.innerHTML = `<h3 style="color:#00bcd4">${u.name}</h3><p style="color:#ccc">${u.desc}</p>`;
        d.onclick = () => { u.apply(); document.getElementById('draft-screen').style.display='none'; document.getElementById('start-wave-btn').style.display='inline-block'; };
        box.appendChild(d);
    }
    document.getElementById('draft-screen').style.display = 'flex';
}

function loop() {
    ctx.fillStyle = '#333'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#555'; ctx.lineWidth = 40; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y); ctx.stroke();
    gameState.towers.forEach(t => { t.update(); t.draw(); });
    gameState.enemies.forEach(e => { e.update(); e.draw(); });
    gameState.projectiles.forEach(p => { p.update(); p.draw(); });
    
    // Áπ™Ë£ΩÈ†êË¶Ω (Âú®ÂØ¶È´î‰πãÂæåÔºåUI‰πãÂâç)
    drawBuildPreview();

    if(gameState.isWaveActive && gameState.enemies.length > 0 && !gameState.enemies.some(e=>e.active)) {
        if (!gameState.isEndingWave) { gameState.isEndingWave = true; setTimeout(endWave, 500); }
    }
    requestAnimationFrame(loop);
}
initGameData(); loop();
</script>
</body>
</html>
