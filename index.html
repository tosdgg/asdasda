<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Roguelike TD V14.0 - Map Loader</title>
    <style>
        body { margin: 0; background: #222; color: #fff; font-family: 'Microsoft JhengHei', sans-serif; overflow: hidden; }
        #game-container { position: relative; display: flex; justify-content: center; margin-top: 20px; }
        canvas { background: #333; border: 2px solid #555; cursor: crosshair; }
        
        #ui-layer { position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 800px; height: 600px; pointer-events: none; }
        .hud { position: absolute; top: 10px; left: 10px; font-size: 18px; font-weight: bold; pointer-events: auto; text-shadow: 1px 1px 2px black; }
        
        #upgrade-menu {
            display: none; position: absolute; background: rgba(20, 20, 30, 0.95); 
            border: 2px solid #00bcd4; padding: 15px; border-radius: 8px; pointer-events: auto;
            flex-direction: column; gap: 8px; min-width: 180px; z-index: 30;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #upgrade-menu h4 { margin: 0 0 5px 0; color: #00bcd4; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .stat-row { display: flex; justify-content: space-between; font-size: 13px; color: #ccc; margin-bottom: 2px; }
        .stat-val { color: #fff; font-weight: bold; }
        
        .btn-action { border: none; color: white; padding: 8px; cursor: pointer; border-radius: 4px; width: 100%; margin-top:5px; font-weight: bold; transition: 0.2s;}
        .btn-upgrade { background: #e67e22; } .btn-upgrade:hover { background: #d35400; }
        .btn-rotate { background: #3498db; } .btn-rotate:hover { background: #2980b9; }
        .btn-sell { background: #c0392b; } .btn-sell:hover { background: #a93226; }
        .btn-close { background: #555; margin-top: 10px;} .btn-close:hover { background: #666; }
        .btn-action:disabled { background: #444; cursor: not-allowed; opacity: 0.6; }

        #hero-bar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; pointer-events: auto; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 10px;
        }
        .hero-btn {
            width: 70px; height: 70px; border: 2px solid #555; border-radius: 8px; background: #333;
            cursor: pointer; position: relative; overflow: hidden; transition: 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .hero-btn:hover { border-color: #ffd700; transform: translateY(-5px); }
        .hero-btn.active { border-color: #00ff00; box-shadow: 0 0 10px #00ff00; }
        .hero-btn.disabled { filter: grayscale(100%); cursor: not-allowed; opacity: 0.5; }
        
        /* è®“æŒ‰éˆ•å…§çš„å½±ç‰‡å¡«æ»¿ */
        .hero-btn video { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        
        .hero-cost { position: absolute; bottom: 0; right: 0; background: rgba(0,0,0,0.8); color: #ffd700; font-size: 10px; padding: 2px 4px; }
        .hero-limit { position: absolute; top: 0; left: 0; background: rgba(255,0,0,0.8); color: #fff; font-size: 10px; padding: 2px 4px; display: none; }
        .hero-btn.disabled .hero-limit { display: block; }

        #draft-screen { 
            display: flex; position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 10;
        }
        .cards-container { display: flex; gap: 20px; }
        .card { width: 200px; height: 280px; background: #444; border: 2px solid #666; border-radius: 10px; padding: 20px; cursor: pointer; text-align: center; display: flex; flex-direction: column; justify-content: center;}
        
        #controls { position: absolute; top: 50px; width: 100%; text-align: center; pointer-events: none; text-shadow: 1px 1px 2px #000; }
        button.start-btn { pointer-events: auto; padding: 10px 30px; font-size: 20px; background: #28a745; border: none; color: white; cursor: pointer; border-radius: 5px; display: none; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div class="hud">
            <div>â¤ï¸ ç”Ÿå‘½: <span id="lives">20</span></div>
            <div>ğŸ’° é‡‘å¹£: <span id="money">300</span></div>
            <div>ğŸŒŠ æ³¢æ•¸: <span id="wave">1</span></div>
            <div style="font-size: 14px; color: #aaa; margin-top: 5px;">æ•µäººæ•¸é‡: <span id="enemy-count">0</span></div>
        </div>

        <div id="upgrade-menu">
            <h4 id="menu-title">å¡”è³‡è¨Š</h4>
            <div class="stat-row"><span>âš”ï¸ æ”»æ“Š:</span> <span class="stat-val" id="menu-dmg">0</span></div>
            <div class="stat-row"><span>ğŸ¯ ç¯„åœ:</span> <span class="stat-val" id="menu-rng">0</span></div>
            <div class="stat-row"><span>ğŸ›¡ï¸ é˜»æ“‹:</span> <span class="stat-val" id="menu-blk">0</span></div>
            <button class="btn-action btn-upgrade" id="btn-upgrade-action" onclick="upgradeSelectedTower()">å‡ç´š</button>
            <button class="btn-action btn-rotate" id="btn-rotate-action" onclick="rotateSelectedTower()">ğŸ”„ æ—‹è½‰ (å³)</button>
            <button class="btn-action btn-sell" id="btn-sell-action" onclick="sellSelectedTower()">å‡ºå”®</button>
            <button class="btn-action btn-close" onclick="closeMenu()">é—œé–‰</button>
        </div>

        <div id="hero-bar">
            <div class="hero-btn active" id="btn-basic" onclick="selectBuildMode('BASIC')">
                <div style="font-size:12px;color:#ccc">åŸºç¤å¡”</div>
                <div class="hero-cost">$50</div>
            </div>
            </div>

        <div id="draft-screen">
            <h2 id="draft-title">Loading Maps & Data...</h2>
            <div class="cards-container" id="cards-container"></div>
        </div>

        <div id="controls">
            <p>æ³¡æ³¡è‹±é›„æ”»æ“Šå‰æ–¹çŸ©å½¢ç¯„åœ | é»æ“Šè‹±é›„å¯èª¿æ•´ 4 å€‹æ–¹å‘</p>
            <button class="start-btn" id="start-wave-btn" onclick="startWave()">ä¸‹ä¸€æ³¢</button>
        </div>
    </div>
</div>

<script>
// --- 1. è³‡æ–™ä¾†æºè¨­å®š (æ›´æ–°çš„ GID) ---
const UPGRADE_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?output=csv';

// Sheet 2: æ•µäºº (gid=164420776)
const ENEMY_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?gid=164420776&output=csv';

// Sheet 3: åœ°åœ– (gid=1573121303)
const MAP_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?gid=1573121303&output=csv';

// è‹±é›„é…ç½®
const HERO_CONFIG = [
    {
        id: 'hero_bubble',
        name: 'æ³¡æ³¡é¾',
        cost: 150,
        // icon: è‡ªå‹•ä½¿ç”¨ä¸‹æ–¹çš„ front_idle ä½œç‚ºæŒ‰éˆ•å‹•ç•«
        anim: {
            front_idle: 'https://cdn.discordapp.com/attachments/795309314352087045/1462581270524461188/---Idle-x1.webm?ex=696eb674&is=696d64f4&hm=fb69f07b3d9c68ba46b8102a170e992a771dd54a70833aa8117228036b1d891c&',
            front_attack: 'https://cdn.discordapp.com/attachments/795309314352087045/1462581981060530327/---Skill_2_Idle_A-x1.webm?ex=696eb71d&is=696d659d&hm=885403ba7659a04fc3c4a602373fd0ffccd65497e13b61803fd4ffb24e026319&',
            back_idle: 'https://cdn.discordapp.com/attachments/795309314352087045/1462582587183857891/---Idle-x1.webm?ex=696eb7ae&is=696d662e&hm=5e2d3dce41f037c1120cf2d0d4297e7e0682255dfb6b2e9b3dd010817d10feae&',
            back_attack: 'https://cdn.discordapp.com/attachments/795309314352087045/1462582587758481560/---Skill_2_Idle_A-x1.webm?ex=696eb7ae&is=696d662e&hm=fb6e88670ed1c10bf572204992d6b1598d7d4eb4d707563cec2d95c919e8df4f&'
        },
        stats: { dmg: 20, rng: 200, spd: 30, block: 2 },
        scale: { dmg: 10, rng: 10 },
        placed: false
    }
];

let buildMode = 'BASIC';
let selectedHeroConfig = null;
let loadedUpgrades = [], loadedEnemyTypes = [];
let path = []; // åœ°åœ–è·¯å¾‘ç¾åœ¨æ˜¯è®Šæ•¸ï¼Œç­‰å¾… CSV è¼‰å…¥
let specialStats = { slowFactor: 0, splashRadius: 0 };
let mousePos = { x: -100, y: -100 };

// --- CSV è§£æå™¨ ---
function parseCSV(text) {
    const lines = text.trim().split('\n');
    const headers = lines[0].split(',').map(h => h.trim());
    const data = [];
    for (let i = 1; i < lines.length; i++) {
        const currentline = lines[i].split(',');
        if(currentline.length < headers.length) continue;
        let obj = {};
        for (let j = 0; j < headers.length; j++) obj[headers[j]] = currentline[j] ? currentline[j].trim() : "";
        data.push(obj);
    }
    return data;
}

// è©æ¢è§£æ (æ–°ç‰ˆ)
function applyTags(tagString) {
    if (!tagString) return;
    const regex = /#([a-zA-Z]+)([-]?\d+(\.\d+)?)/g;
    let match;
    while ((match = regex.exec(tagString)) !== null) {
        const code = match[1].toLowerCase(); 
        const val = parseFloat(match[2]);
        switch(code) {
            case 'dmg': playerStats.globalDamage += val; break;
            case 'rng': case 'rag': playerStats.globalRange += val; break;
            case 'spd': playerStats.globalFireRate = Math.max(5, playerStats.globalFireRate - val); break;
            case 'coin': case 'gold': playerStats.goldMultiplier += (val / 100); break;
            case 'hp': updateLives(val); break;
            case 'ice': specialStats.slowFactor = Math.min(0.8, specialStats.slowFactor + (val/100)); break;
            case 'aoe': specialStats.splashRadius += val; break;
        }
    }
}

function mapUpgrades(data) {
    return data.map(item => {
        const tags = item['tags'] || item['Tags'];
        // å…¼å®¹èˆŠæ ¼å¼
        const type = (item['type'] || item['Type'] || '').toUpperCase();
        const val = parseFloat(item['value'] || item['Value'] || 0);
        return {
            name: item['name'] || 'æœªçŸ¥', desc: item['description'] || '',
            apply: () => {
                if (tags) applyTags(tags);
                else if (type) {
                    let t = "";
                    if(type==='DMG') t=`#dmg${val}`; else if(type==='RNG') t=`#rng${val}`;
                    else if(type==='SPD') t=`#spd${val}`;
                    applyTags(t);
                }
            }
        };
    });
}

function mapEnemies(data) {
    return data.filter(item => item['name']).map(item => ({
        name: item['name'],
        baseHp: parseFloat(item['hp']||50)||50, speed: parseFloat(item['speed']||1.5)||1.5,
        gold: parseFloat(item['gold']||15)||15, weight: parseFloat(item['weight']||10)||10
    }));
}

// åœ°åœ–è§£æå™¨ (New!)
function mapPathData(data) {
    // å‡è¨­ CSV æ¬„ä½æ˜¯ x, y
    return data.map(p => ({
        x: parseInt(p.x || p.X || 0),
        y: parseInt(p.y || p.Y || 0)
    })).filter(p => !isNaN(p.x) && !isNaN(p.y)); // éæ¿¾ç„¡æ•ˆé»
}

function getRandomEnemyType() {
    if (!loadedEnemyTypes.length) return { name: "BUG", baseHp: 50, speed: 1, gold: 10, weight: 1 };
    const totalWeight = loadedEnemyTypes.reduce((sum, type) => sum + type.weight, 0);
    let random = Math.random() * totalWeight;
    for (const type of loadedEnemyTypes) {
        if (random < type.weight) return type;
        random -= type.weight;
    }
    return loadedEnemyTypes[0];
}

async function initGameData() {
    try {
        // åŒæ™‚è®€å– 3 å€‹ CSV
        const [uRes, eRes, mRes] = await Promise.all([
            fetch(UPGRADE_CSV_URL), 
            fetch(ENEMY_CSV_URL),
            fetch(MAP_CSV_URL)
        ]);

        loadedUpgrades = mapUpgrades(parseCSV(await uRes.text()));
        loadedEnemyTypes = mapEnemies(parseCSV(await eRes.text()));
        
        // è¼‰å…¥åœ°åœ–
        const rawMap = parseCSV(await mRes.text());
        path = mapPathData(rawMap);
        
        // å¦‚æœåœ°åœ–è®€å–å¤±æ•—ï¼Œä½¿ç”¨é è¨­å€¼
        if (path.length < 2) throw new Error("Map data invalid");

        console.log("Map Loaded:", path.length, "points");
        initHeroUI(); 
        startGameUI();
    } catch (e) {
        console.error("Data Load Error:", e);
        // Fallback
        path = [{x: 0, y: 100}, {x: 800, y: 100}];
        loadedEnemyTypes = [{ name: "é è¨­æ€ª", baseHp: 50, speed: 1.5, gold: 10, weight: 100 }];
        initHeroUI(); 
        startGameUI();
    }
}

function initHeroUI() {
    const bar = document.getElementById('hero-bar');
    HERO_CONFIG.forEach(hero => {
        const btn = document.createElement('div');
        btn.className = 'hero-btn';
        btn.id = `btn-${hero.id}`;
        btn.onclick = () => selectBuildMode(hero.id);
        
        // ä½¿ç”¨ Front Idle å‹•ç•«ä½œç‚ºæŒ‰éˆ•é ­åƒ
        btn.innerHTML = `
            <video src="${hero.anim.front_idle}" autoplay loop muted></video>
            <div class="hero-cost">$${hero.cost}</div>
            <div class="hero-limit">å·²æ”¾ç½®</div>
        `;
        bar.appendChild(btn);
    });
}

function selectBuildMode(mode) {
    document.querySelectorAll('.hero-btn').forEach(b => b.classList.remove('active'));
    if (mode === 'BASIC') {
        buildMode = 'BASIC'; selectedHeroConfig = null;
        document.getElementById('btn-basic').classList.add('active');
    } else {
        const hero = HERO_CONFIG.find(h => h.id === mode);
        if (hero.placed) { alert("æ­¤è‹±é›„åªèƒ½æ”¾ä¸€å€‹ï¼"); return; }
        buildMode = mode; selectedHeroConfig = hero;
        document.getElementById(`btn-${mode}`).classList.add('active');
    }
}

function startGameUI() {
    document.getElementById('draft-screen').style.display = 'none';
    document.getElementById('start-wave-btn').style.display = 'inline-block';
}

// --- éŠæˆ²æ ¸å¿ƒ ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameState = { lives: 20, money: 300, wave: 1, enemies: [], towers: [], projectiles: [], isWaveActive: false, isEndingWave: false };
let playerStats = { globalDamage: 0, globalRange: 0, globalFireRate: 60, goldMultiplier: 1.0, baseDamage: 15 };

class Enemy {
    constructor(wave) {
        const type = getRandomEnemyType();
        this.name = type.name; this.goldReward = type.gold;
        this.pathIndex = 0; 
        // ç¢ºä¿åœ°åœ–å·²è¼‰å…¥
        if (path.length > 0) {
            this.x = path[0].x; this.y = path[0].y;
        } else {
            this.x = 0; this.y = 0;
        }
        this.baseSpeed = type.speed; this.currentSpeed = this.baseSpeed;
        const scaleMultiplier = Math.pow(1.2, wave - 1);
        this.hp = Math.floor(type.baseHp * scaleMultiplier);
        this.maxHp = this.hp;
        this.active = true;
        this.blockedBy = null;
    }
    update() {
        if (!this.active) return;
        if (this.blockedBy) {
            if (!this.blockedBy.active) this.blockedBy = null;
            else return;
        }
        let target = path[this.pathIndex + 1];
        if (!target) { this.active = false; updateLives(-1); return; }
        let dx = target.x - this.x, dy = target.y - this.y, dist = Math.hypot(dx, dy);
        if (dist < this.currentSpeed) { this.x = target.x; this.y = target.y; this.pathIndex++; } 
        else { this.x += (dx/dist)*this.currentSpeed; this.y += (dy/dist)*this.currentSpeed; }
    }
    takeDamage(dmg) {
        this.hp -= dmg;
        if (this.hp <= 0 && this.active) {
            this.active = false;
            if (this.blockedBy) this.blockedBy.releaseBlock(this);
            updateMoney(Math.floor(this.goldReward * playerStats.goldMultiplier));
        }
    }
    draw() {
        if (!this.active) return;
        ctx.fillStyle = 'white'; ctx.font = "bold 16px Arial"; ctx.textAlign = "center";
        ctx.strokeStyle = "black"; ctx.lineWidth = 3;
        ctx.strokeText(this.name, this.x, this.y); ctx.fillText(this.name, this.x, this.y);
        ctx.fillStyle = "red"; ctx.fillRect(this.x-20, this.y-15, 40, 4);
        ctx.fillStyle = "#00ff00"; ctx.fillRect(this.x-20, this.y-15, 40 * (this.hp/this.maxHp), 4);
    }
}

class Tower {
    constructor(x, y, heroConfig = null) { 
        this.x = x; this.y = y; this.cooldown = 0; this.level = 1; this.active = true;
        this.isHero = !!heroConfig;
        
        if (this.isHero) {
            this.heroId = heroConfig.id;
            this.baseDamage = heroConfig.stats.dmg;
            this.baseRange = heroConfig.stats.rng;
            this.fireRate = heroConfig.stats.spd;
            this.blockCount = heroConfig.stats.block || 0;
            this.scale = heroConfig.scale;
            this.totalCost = heroConfig.cost;
            this.name = heroConfig.name;
            
            this.media = {
                front_idle: this.createVideo(heroConfig.anim.front_idle),
                front_attack: this.createVideo(heroConfig.anim.front_attack),
                back_idle: this.createVideo(heroConfig.anim.back_idle),
                back_attack: this.createVideo(heroConfig.anim.back_attack),
            };

            this.dir = 0; 
            this.isAttacking = false; 
            this.blockedEnemies = [];

        } else {
            this.baseDamage = playerStats.baseDamage; this.baseRange = 100;
            this.fireRate = playerStats.globalFireRate; this.totalCost = 50;
            this.name = "åŸºç¤å¡”";
        }
        this.levelDamage = 0; this.levelRange = 0;
    }

    createVideo(src) {
        const v = document.createElement('video');
        v.src = src; v.muted = true; v.loop = true; 
        v.autoplay = false; v.playsInline = true;
        return v;
    }

    getDamage() { return this.isHero ? this.baseDamage + this.levelDamage : playerStats.baseDamage + playerStats.globalDamage + this.levelDamage; }
    getRange() { return this.isHero ? this.baseRange + this.levelRange : this.baseRange + playerStats.globalRange + this.levelRange; }
    getFireRate() { return this.isHero ? this.fireRate : playerStats.globalFireRate; }
    
    upgrade() { 
        this.level++;
        if (this.isHero) { this.levelDamage += this.scale.dmg; this.levelRange += this.scale.rng; this.totalCost += this.level * 200; } 
        else { this.levelDamage += 15; this.levelRange += 15; this.totalCost += (this.level - 1) * 150; }
    }

    releaseBlock(enemy) { this.blockedEnemies = this.blockedEnemies.filter(e => e !== enemy); }
    
    isInRectRange(e, range, width) {
        const dx = e.x - this.x;
        const dy = e.y - this.y;
        if (this.dir === 0) return dx > 0 && dx < range && Math.abs(dy) < width;
        if (this.dir === 1) return dy > 0 && dy < range && Math.abs(dx) < width;
        if (this.dir === 2) return dx < 0 && dx > -range && Math.abs(dy) < width;
        if (this.dir === 3) return dy < 0 && dy > -range && Math.abs(dx) < width;
        return false;
    }

    update() {
        if (this.isHero) {
            if (this.blockedEnemies.length < this.blockCount) {
                gameState.enemies.forEach(e => {
                    if (e.active && !e.blockedBy && this.blockedEnemies.length < this.blockCount) {
                        if (Math.hypot(e.x - this.x, e.y - this.y) < 40) {
                            e.blockedBy = this;
                            this.blockedEnemies.push(e);
                        }
                    }
                });
            }

            let hasTarget = false;
            const range = this.getRange();
            const width = 40; 
            gameState.enemies.forEach(e => {
                if (e.active && this.isInRectRange(e, range, width)) {
                    hasTarget = true;
                }
            });

            this.isAttacking = hasTarget;
            this.updateVideoState();

            if (this.cooldown > 0) this.cooldown--;
            if (this.cooldown <= 0 && hasTarget) {
                let vx = 0, vy = 0;
                if (this.dir === 0) vx = 10;
                if (this.dir === 1) vy = 10;
                if (this.dir === 2) vx = -10;
                if (this.dir === 3) vy = -10;
                gameState.projectiles.push(new Projectile(this.x, this.y, vx, vy, this.getDamage(), true));
                this.cooldown = this.getFireRate();
            }

        } else {
            if (this.cooldown > 0) this.cooldown--;
            if (this.cooldown <= 0) {
                let target = null, minDist = Infinity, range = this.getRange();
                gameState.enemies.forEach(e => {
                    if (!e.active) return;
                    let dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if (dist <= range && dist < minDist) { minDist = dist; target = e; }
                });
                if (target) {
                    let dx = target.x - this.x, dy = target.y - this.y;
                    let dist = Math.hypot(dx, dy);
                    let vx = (dx/dist)*10, vy = (dy/dist)*10;
                    gameState.projectiles.push(new Projectile(this.x, this.y, vx, vy, this.getDamage(), false));
                    this.cooldown = this.getFireRate();
                }
            }
        }
    }
    
    updateVideoState() {
        Object.values(this.media).forEach(v => v.pause());
        let activeVideo = null;
        if (this.dir === 3) { 
            activeVideo = this.isAttacking ? this.media.back_attack : this.media.back_idle;
        } else { 
            activeVideo = this.isAttacking ? this.media.front_attack : this.media.front_idle;
        }
        if (activeVideo) activeVideo.play();
    }

    draw() {
        if (this.isHero) {
            let activeVideo = null;
            if (this.dir === 3) { 
                activeVideo = this.isAttacking ? this.media.back_attack : this.media.back_idle;
            } else { 
                activeVideo = this.isAttacking ? this.media.front_attack : this.media.front_idle;
            }

            ctx.save(); 
            ctx.translate(this.x, this.y); 
            if (this.dir === 2) ctx.scale(-1, 1);
            
            // ç¹ªè£½å½±ç‰‡: æ”¾å¤§å°ºå¯¸ (150x150)
            if (activeVideo && activeVideo.readyState >= 2) {
                // åŸæœ¬æ˜¯ -50, -80, 100, 100
                // ç¾åœ¨æ”¾å¤§åˆ° 150x150, åç§»é‡ä¹Ÿè¦èª¿æ•´ (ç´„ -75, -110)
                ctx.drawImage(activeVideo, -75, -110, 150, 150);
            }
            ctx.restore(); 
            
            ctx.fillStyle = '#fff'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`Lv.${this.level}`, this.x, this.y - 75);
            ctx.fillStyle = '#f1c40f';
            ctx.fillText(`ğŸ›¡ï¸ ${this.blockedEnemies.length}/${this.blockCount}`, this.x, this.y + 10);
            
            if (selectedTower === this) {
                this.drawRangeRect(this.getRange(), 40);
            }

        } else {
            ctx.fillStyle = this.level === 1 ? '#4a90e2' : (this.level === 2 ? '#9b59b6' : '#f1c40f');
            ctx.fillRect(this.x-15, this.y-15, 30, 30);
            ctx.fillStyle = '#fff'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText("Lv."+this.level, this.x, this.y - 23);
            if(selectedTower === this) { 
                ctx.strokeStyle='#00bcd4'; ctx.lineWidth=2; 
                ctx.beginPath(); ctx.arc(this.x,this.y,this.getRange(),0,Math.PI*2); ctx.stroke(); 
            }
        }
    }

    drawRangeRect(range, width) {
        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.dir === 1) ctx.rotate(Math.PI / 2);
        if (this.dir === 2) ctx.rotate(Math.PI);
        if (this.dir === 3) ctx.rotate(-Math.PI / 2);
        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
        ctx.fillRect(0, -width, range, width * 2); 
        ctx.strokeStyle = '#ffd700';
        ctx.strokeRect(0, -width, range, width * 2);
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, vx, vy, damage, isPenetrating) { 
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.damage = damage; this.active = true; 
        this.isPenetrating = isPenetrating; this.hitList = []; 
    }
    update() {
        if (!this.active) return;
        this.x += this.vx; this.y += this.vy;
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.active = false;
        
        gameState.enemies.forEach(e => {
            if (!e.active) return;
            if (this.isPenetrating && this.hitList.includes(e)) return;
            if (Math.hypot(e.x - this.x, e.y - this.y) < 25) { 
                e.takeDamage(this.damage);
                if (this.isPenetrating) this.hitList.push(e); else this.active = false;
            }
        });
    }
    draw() { 
        if (!this.active) return; 
        if (this.isPenetrating) {
            ctx.fillStyle = 'rgba(0, 191, 255, 0.6)';
            ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fill(); 
            ctx.strokeStyle = '#fff'; ctx.lineWidth=1; ctx.stroke();
        } else {
            ctx.fillStyle = '#ffeb3b'; 
            ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill(); 
        }
    }
}

let selectedTower = null; const upgradeMenu = document.getElementById('upgrade-menu');
canvas.addEventListener('mousemove', (e) => { const rect = canvas.getBoundingClientRect(); mousePos.x = e.clientX - rect.left; mousePos.y = e.clientY - rect.top; });
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect(), x = e.clientX - rect.left, y = e.clientY - rect.top;
    const clicked = gameState.towers.find(t => Math.hypot(t.x-x, t.y-y) < 30);
    if (clicked) { openUpgradeMenu(clicked, e.clientX, e.clientY); } else {
        closeMenu();
        const overlap = gameState.towers.some(t => Math.hypot(t.x-x, t.y-y) < 30);
        if (!overlap) {
            if (buildMode === 'BASIC' && gameState.money >= 50) { gameState.towers.push(new Tower(x, y)); updateMoney(-50); } 
            else if (selectedHeroConfig && !selectedHeroConfig.placed && gameState.money >= selectedHeroConfig.cost) {
                gameState.towers.push(new Tower(x, y, selectedHeroConfig)); updateMoney(-selectedHeroConfig.cost);
                selectedHeroConfig.placed = true; document.getElementById(`btn-${selectedHeroConfig.id}`).classList.add('disabled'); selectBuildMode('BASIC');
            }
        }
    }
});

function drawBuildPreview() {
    if (selectedTower) return;
    const overlap = gameState.towers.some(t => Math.hypot(t.x - mousePos.x, t.y - mousePos.y) < 30);
    ctx.globalAlpha = 0.5;
    if (buildMode !== 'BASIC' && selectedHeroConfig) {
        const range = selectedHeroConfig.stats.rng;
        const width = 40;
        ctx.fillStyle = overlap ? 'rgba(255,0,0,0.2)' : 'rgba(255, 215, 0, 0.3)';
        ctx.fillRect(mousePos.x, mousePos.y - width, range, width * 2);
        ctx.strokeStyle = '#ffd700'; ctx.strokeRect(mousePos.x, mousePos.y - width, range, width * 2);
    } else {
        const range = 100 + playerStats.globalRange;
        ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, range, 0, Math.PI*2);
        ctx.fillStyle = overlap ? 'rgba(255,0,0,0.2)' : 'rgba(74, 144, 226, 0.2)'; ctx.fill();
        ctx.strokeStyle = '#4a90e2'; ctx.lineWidth = 1; ctx.stroke();
    }
    ctx.globalAlpha = 1.0;
}

function openUpgradeMenu(tower, mx, my) {
    selectedTower = tower;
    let cost = tower.isHero ? (tower.level + 1) * 200 : tower.level * 150;
    const sellPrice = Math.floor(tower.totalCost * 0.7);
    document.getElementById('menu-title').innerText = `${tower.name} Lv.${tower.level}`;
    document.getElementById('menu-dmg').innerText = Math.floor(tower.getDamage());
    document.getElementById('menu-rng').innerText = Math.floor(tower.getRange());
    document.getElementById('menu-blk').innerText = tower.isHero ? tower.blockCount : 0;
    const btnUp = document.getElementById('btn-upgrade-action');
    btnUp.innerText = `å‡ç´š (-$${cost})`;
    btnUp.onclick = () => { if (gameState.money >= cost) { updateMoney(-cost); selectedTower.upgrade(); closeMenu(); } };
    const btnRot = document.getElementById('btn-rotate-action');
    if (tower.isHero) {
        btnRot.style.display = 'block';
        const dirs = ['å³', 'ä¸‹', 'å·¦', 'ä¸Š'];
        btnRot.innerText = `ğŸ”„ æ—‹è½‰ (${dirs[tower.dir]})`;
        btnRot.onclick = rotateSelectedTower;
    } else btnRot.style.display = 'none';
    const btnSell = document.getElementById('btn-sell-action');
    btnSell.innerText = `å‡ºå”® (+$${sellPrice})`;
    upgradeMenu.style.left = (mx + 10) + 'px'; upgradeMenu.style.top = (my - 120) + 'px'; upgradeMenu.style.display = 'flex';
}
function rotateSelectedTower() {
    if (selectedTower && selectedTower.isHero) {
        selectedTower.dir = (selectedTower.dir + 1) % 4;
        const dirs = ['å³', 'ä¸‹', 'å·¦', 'ä¸Š'];
        document.getElementById('btn-rotate-action').innerText = `ğŸ”„ æ—‹è½‰ (${dirs[selectedTower.dir]})`;
    }
}
function sellSelectedTower() {
    if (!selectedTower) return;
    updateMoney(Math.floor(selectedTower.totalCost * 0.7));
    if (selectedTower.isHero) {
        selectedTower.blockedEnemies.forEach(e => e.blockedBy = null);
        const config = HERO_CONFIG.find(h => h.id === selectedTower.heroId);
        if (config) { config.placed = false; document.getElementById(`btn-${config.id}`).classList.remove('disabled'); }
    }
    selectedTower.active = false;
    gameState.towers = gameState.towers.filter(t => t !== selectedTower); closeMenu();
}
function closeMenu() { selectedTower = null; upgradeMenu.style.display = 'none'; }
function updateMoney(v) { gameState.money += v; document.getElementById('money').innerText = gameState.money; }
function updateLives(v) { gameState.lives += v; document.getElementById('lives').innerText = gameState.lives; if(gameState.lives<=0) { alert("Game Over"); location.reload(); } }
function startWave() {
    if (gameState.isWaveActive) return;
    gameState.isWaveActive = true; gameState.isEndingWave = false; 
    document.getElementById('start-wave-btn').style.display = 'none'; closeMenu();
    let max = 5 + (gameState.wave * 3); 
    let interval = Math.max(200, 800 - (gameState.wave * 20));
    document.getElementById('enemy-count').innerText = max;
    let count = 0;
    const spawner = setInterval(() => {
        if(!gameState.isWaveActive) { clearInterval(spawner); return; }
        try { gameState.enemies.push(new Enemy(gameState.wave)); } catch(e) {}
        count++; if(count >= max) clearInterval(spawner);
    }, interval);
}
function endWave() {
    gameState.isWaveActive = false; gameState.enemies = []; gameState.projectiles = [];
    gameState.wave++; document.getElementById('wave').innerText = gameState.wave;
    document.getElementById('draft-screen').style.display = 'flex';
}
function loop() {
    ctx.fillStyle = '#333'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ç¹ªè£½åœ°åœ–è·¯å¾‘ (å¦‚æœæœ‰çš„è©±)
    if (path.length > 0) {
        ctx.strokeStyle = '#555'; ctx.lineWidth = 40; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); 
        for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y); 
        ctx.stroke();
    }

    gameState.towers.forEach(t => { t.update(); t.draw(); });
    gameState.enemies.forEach(e => { e.update(); e.draw(); });
    gameState.projectiles.forEach(p => { p.update(); p.draw(); });
    drawBuildPreview();
    if(gameState.isWaveActive && gameState.enemies.length > 0 && !gameState.enemies.some(e=>e.active)) {
        if (!gameState.isEndingWave) { gameState.isEndingWave = true; setTimeout(endWave, 500); }
    }
    requestAnimationFrame(loop);
}
initGameData(); loop();
</script>
</body>
</html>
