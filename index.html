<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Roguelike TD V24.0 - Configurable Update</title>
    <style>
        body { margin: 0; background: #222; color: #fff; font-family: 'Microsoft JhengHei', sans-serif; overflow: hidden; }
        #game-container { position: relative; display: flex; justify-content: center; margin-top: 20px; }
        canvas { background: #333; border: 2px solid #555; cursor: crosshair; }
        
        #ui-layer { position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 800px; height: 600px; pointer-events: none; }
        .hud { position: absolute; top: 10px; left: 10px; font-size: 18px; font-weight: bold; pointer-events: auto; text-shadow: 1px 1px 2px black; }
        
        #upgrade-menu {
            display: none; position: absolute; background: rgba(20, 20, 30, 0.95); 
            border: 2px solid #00bcd4; padding: 15px; border-radius: 8px; pointer-events: auto;
            flex-direction: column; gap: 8px; min-width: 180px; z-index: 30;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #upgrade-menu h4 { margin: 0 0 5px 0; color: #00bcd4; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .stat-row { display: flex; justify-content: space-between; font-size: 13px; color: #ccc; margin-bottom: 2px; }
        .stat-val { color: #fff; font-weight: bold; }
        
        .btn-action { border: none; color: white; padding: 8px; cursor: pointer; border-radius: 4px; width: 100%; margin-top:5px; font-weight: bold; transition: 0.2s;}
        .btn-upgrade { background: #e67e22; } .btn-upgrade:hover { background: #d35400; }
        .btn-rotate { background: #3498db; } .btn-rotate:hover { background: #2980b9; }
        .btn-skill { background: #9b59b6; display: none; } .btn-skill:hover { background: #8e44ad; }
        .btn-sell { background: #c0392b; } .btn-sell:hover { background: #a93226; }
        .btn-close { background: #555; margin-top: 10px;} .btn-close:hover { background: #666; }
        .btn-action:disabled { background: #444; cursor: not-allowed; opacity: 0.6; }
        
        #hero-bar {
            position: absolute; bottom: 10px; left: 20px;
            display: flex; gap: 10px; pointer-events: auto; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 10px;
            max-width: 700px; overflow-x: auto;
        }
        .hero-btn {
            width: 70px; height: 70px; border: 2px solid #555; border-radius: 8px; background: #333; flex-shrink: 0;
            cursor: pointer; position: relative; overflow: hidden; transition: 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .hero-btn:hover { border-color: #ffd700; transform: translateY(-5px); }
        .hero-btn.active { border-color: #00ff00; box-shadow: 0 0 10px #00ff00; }
        .hero-btn.disabled { filter: grayscale(100%); cursor: not-allowed; opacity: 0.5; }
        .hero-btn video { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .hero-cost { position: absolute; bottom: 0; right: 0; background: rgba(0,0,0,0.8); color: #ffd700; font-size: 10px; padding: 2px 4px; }
        .hero-limit { position: absolute; top: 0; left: 0; background: rgba(255,0,0,0.8); color: #fff; font-size: 10px; padding: 2px 4px; display: none; }
        .hero-btn.disabled .hero-limit { display: block; }

        #draft-screen { 
            display: flex; position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 10;
        }
        .cards-container { display: flex; gap: 20px; }
        .card { width: 200px; height: 280px; background: #444; border: 2px solid #666; border-radius: 10px; padding: 20px; cursor: pointer; text-align: center; display: flex; flex-direction: column; justify-content: center;}
        
        #loading-msg { color: #00bcd4; font-size: 24px; }
        #controls { position: absolute; bottom: 20px; right: 20px; pointer-events: none; }
        button.start-btn { 
            pointer-events: auto; padding: 15px 40px; font-size: 24px; 
            background: #28a745; border: 2px solid #1e7e34; color: white; 
            cursor: pointer; border-radius: 8px; display: none; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); font-family: 'Microsoft JhengHei', sans-serif; font-weight: bold;
        }
        button.start-btn:hover { background: #218838; transform: scale(1.05); }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui-layer">
        <div class="hud">
            <div>‚ù§Ô∏è <span id="lives">20</span> | üí∞ <span id="money">300</span> | üåä <span id="wave">1</span></div>
            <div style="font-size: 14px; color: #aaa;">Enemies: <span id="enemy-count">0</span></div>
        </div>

        <div id="upgrade-menu">
            <h4 id="menu-title">Â°îË≥áË®ä</h4>
            <div class="stat-row"><span>‚öîÔ∏è ÊîªÊìä:</span> <span class="stat-val" id="menu-dmg">0</span></div>
            <div class="stat-row"><span>üéØ ÁØÑÂúç:</span> <span class="stat-val" id="menu-rng">0</span></div>
            <div class="stat-row"><span>‚ö° ÊîªÈÄü:</span> <span class="stat-val" id="menu-spd">0/s</span></div>
            <div class="stat-row"><span>üõ°Ô∏è ÈòªÊìã:</span> <span class="stat-val" id="menu-blk">0</span></div>
            <button class="btn-action btn-upgrade" id="btn-upgrade-action" onclick="upgradeSelectedTower()">ÂçáÁ¥ö</button>
            <button class="btn-action btn-skill" id="btn-skill-action" onclick="activateSkill()">üåü ÁôºÂãïÊäÄËÉΩ</button>
            <button class="btn-action btn-rotate" id="btn-rotate-action" onclick="rotateSelectedTower()">üîÑ ÊóãËΩâ</button>
            <button class="btn-action btn-sell" id="btn-sell-action" onclick="sellSelectedTower()">Âá∫ÂîÆ</button>
            <button class="btn-action btn-close" onclick="closeMenu()">ÈóúÈñâ</button>
        </div>

        <div id="hero-bar">
            <div class="hero-btn active" id="btn-basic" onclick="selectBuildMode('BASIC')">
                <div style="font-size:12px;color:#ccc">Âü∫Á§éÂ°î</div>
                <div class="hero-cost">$50</div>
            </div>
        </div>

        <div id="draft-screen">
            <h2 id="draft-title">Loading...</h2>
            <div id="loading-msg">Loading...</div>
            <div class="cards-container" id="cards-container"></div>
        </div>

        <div id="controls">
            <button class="start-btn" id="start-wave-btn" onclick="startWave()">‰∏ã‰∏ÄÊ≥¢</button>
        </div>
    </div>
</div>

<script>
// --- Config ---
// Ë´ãÁ¢∫‰øù Google Sheet Â∑≤Êñ∞Â¢û skill_cd Âíå attack_type Ê¨Ñ‰Ωç
const HERO_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?gid=698676469&output=csv';
const UPGRADE_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?output=csv';
const ENEMY_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?gid=164420776&output=csv';
const MAP_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSrSpOCkX8ZvOlMmbAKsxJWKtQrVe-B8ae021GZ96AtS7yCjF54N94j-ksQQc33xOBqSLMHD24EDxj8/pub?gid=1573121303&output=csv';

const DEFAULT_HERO_DB = [
    {
        id: 'hero_sakiko', name: '‰∏∞Â∑ùÁ••Â≠ê', cost: 150,
        stats: { dmg: 20, rng: 200, spd: 30, block: 2 },
        skill: null, attackType: 'PENETRATE',
        anim: { front_idle: '', front_attack: '', back_idle: '', back_attack: '' }, placed: false
    }
];

let HERO_DB = []; 
let buildMode = 'BASIC';
let selectedHeroConfig = null;
let loadedUpgrades = [], loadedEnemyTypes = [];
let path = []; 
let specialStats = { slowFactor: 0, splashRadius: 0 };
let mousePos = { x: -100, y: -100 };

// --- CSV Helper ---
function parseCSV(text) {
    if (!text) return [];
    const lines = text.trim().split('\n');
    if (lines.length < 2) return [];
    const headers = lines[0].split(',').map(h => h.trim());
    const data = [];
    for (let i = 1; i < lines.length; i++) {
        const currentline = lines[i].split(','); 
        if(currentline.length < headers.length) continue;
        let obj = {};
        for (let j = 0; j < headers.length; j++) obj[headers[j]] = currentline[j] ? currentline[j].trim() : "";
        data.push(obj);
    }
    return data;
}

// üü¢ 1. Êõ¥Êñ∞ Hero Mapping ÊîØÊè¥ CD Âíå Attack Type
function mapHeroes(data) {
    return data.filter(h => h.id).map(h => ({
        id: h.id,
        name: h.name || 'Unknown',
        cost: parseInt(h.cost) || 100,
        stats: {
            dmg: parseInt(h.dmg) || 10,
            rng: parseInt(h.rng) || 100,
            spd: parseInt(h.spd) || 60,
            block: parseInt(h.block) || 0
        },
        skill: (h.skill_type && h.skill_type !== 'NONE') ? {
            type: h.skill_type,
            value: parseFloat(h.skill_val) || 0,
            duration: parseFloat(h.skill_dur) || 0,
            cooldown: parseFloat(h.skill_cd) || 30 // üü¢ È†êË®≠ 30Áßí CD
        } : null,
        // üü¢ ËÆÄÂèñÊîªÊìäÈ°ûÂûãÔºåËã•ÁÑ°ÂâáÊ†πÊìöIDÁåúÊ∏¨ (ÂÖºÂÆπËàäÁâà)
        attackType: h.attack_type ? h.attack_type.toUpperCase() : (h.id.includes('myrtle') ? 'RECT' : (h.id.includes('sakiko') ? 'PENETRATE' : 'PROJECTILE')),
        anim: {
            front_idle: h.anim_front_idle, front_attack: h.anim_front_attack,
            front_skill_begin: h.anim_front_skill_begin, front_skill_loop: h.anim_front_skill_loop, front_skill_end: h.anim_front_skill_end,
            back_idle: h.anim_back_idle, back_attack: h.anim_back_attack,
            back_skill_begin: h.anim_back_skill_begin, back_skill_loop: h.anim_back_skill_loop, back_skill_end: h.anim_back_skill_end
        },
        placed: false
    }));
}

function mapEnemies(data) { return data.filter(i=>i.name).map(i=>({name:i.name, baseHp:parseFloat(i.hp||50), speed:parseFloat(i.speed||1.5), gold:parseFloat(i.gold||15), weight:parseFloat(i.weight||10)})); }
function mapPathData(data) { return data.map(p=>({x:parseInt(p.x||p.X||0), y:parseInt(p.y||p.Y||0)})).filter(p=>!isNaN(p.x)&&!isNaN(p.y)); }
function mapUpgrades(data) { return data.map(item => { 
    const tags = item['tags'] || item['Tags']; const type = (item['type'] || item['Type'] || '').toUpperCase(); const val = parseFloat(item['value'] || item['Value'] || 0);
    return { name: item['name'], desc: item['description'], apply: () => { if(tags) applyTags(tags); else if(type) { let t=""; if(type==='DMG')t=`#dmg${val}`; applyTags(t); } } };
}); }

// üü¢ 2. Â¢ûÂº∑ Ice (Slow) Âíå AoE (Splash) ÁöÑÊï∏ÂÄºÈÇèËºØ
function applyTags(tagString) { 
    if(!tagString)return; const regex=/#([a-zA-Z]+)([-]?\d+(\.\d+)?)/g; let match; while((match=regex.exec(tagString))!==null){
        const c=match[1].toLowerCase(),v=parseFloat(match[2]); 
        if(c==='dmg')playerStats.globalDamage+=v; 
        else if(c==='rng')playerStats.globalRange+=v; 
        else if(c==='spd')playerStats.globalFireRate=Math.max(5,playerStats.globalFireRate-v);
        else if(c==='gold')playerStats.goldMultiplier+=(v/100); 
        else if(c==='hp')updateLives(v); 
        else if(c==='ice') specialStats.slowFactor = Math.min(0.8, specialStats.slowFactor + (v/100)); // ‰∏äÈôê 80% Á∑©ÈÄü
        else if(c==='aoe') specialStats.splashRadius += v; // Â¢ûÂä†ÁàÜÁÇ∏ÂçäÂæë
    }
}
function getRandomEnemyType() { if (!loadedEnemyTypes.length) return { name: "BUG", baseHp: 50, speed: 1, gold: 10, weight: 1 }; const t = loadedEnemyTypes.reduce((s, i) => s + i.weight, 0); let r = Math.random() * t; for (const i of loadedEnemyTypes) { if (r < i.weight) return i; r -= i.weight; } return loadedEnemyTypes[0]; }

// --- Initialization ---
async function initGameData() {
    try {
        const [uRes, eRes, mRes, hRes] = await Promise.all([
            fetch(UPGRADE_CSV_URL), fetch(ENEMY_CSV_URL), fetch(MAP_CSV_URL), fetch(HERO_CSV_URL)
        ]);
        
        loadedUpgrades = mapUpgrades(parseCSV(await uRes.text()));
        loadedEnemyTypes = mapEnemies(parseCSV(await eRes.text()));
        path = mapPathData(parseCSV(await mRes.text()));
        const rawHero = parseCSV(await hRes.text());
        
        if(rawHero.length > 0) HERO_DB = mapHeroes(rawHero);
        else HERO_DB = DEFAULT_HERO_DB;

        if (loadedUpgrades.length === 0) loadedUpgrades.push({ name: "Âü∫Á§éÂΩàËó•", desc: "ÂÇ∑ÂÆ≥+1 (ÂÇôÁî®)", apply: () => playerStats.globalDamage += 1 });
        if (path.length < 2) path = [{x:0,y:100},{x:800,y:100}];
        
        initHeroUI(); 
        startGameUI();
    } catch (e) {
        console.error("Critical Load Error:", e);
        path = [{x: 0, y: 100}, {x: 800, y: 100}];
        loadedEnemyTypes = [{ name: "È†êË®≠ÊÄ™", baseHp: 50, speed: 1.5, gold: 10, weight: 100 }];
        loadedUpgrades = [{ name: "Á∑äÊÄ•‰øÆÂæ©", desc: "Êï∏ÊìöËºâÂÖ•Â§±Êïó", apply: () => playerStats.globalDamage += 1 }];
        HERO_DB = DEFAULT_HERO_DB;
        initHeroUI(); startGameUI();
    }
}

function initHeroUI() {
    const bar = document.getElementById('hero-bar');
    while (bar.children.length > 1) { bar.removeChild(bar.lastChild); }
    HERO_DB.forEach(hero => {
        const btn = document.createElement('div');
        btn.className = 'hero-btn';
        btn.id = `btn-${hero.id}`;
        btn.onclick = () => selectBuildMode(hero.id);
        btn.innerHTML = `
            <video src="${hero.anim.front_idle}" autoplay loop muted></video>
            <div class="hero-cost">$${hero.cost}</div>
            <div class="hero-limit">Â∑≤ÊîæÁΩÆ</div>
        `;
        bar.appendChild(btn);
    });
}

function selectBuildMode(mode) {
    document.querySelectorAll('.hero-btn').forEach(b => b.classList.remove('active'));
    if (mode === 'BASIC') {
        buildMode = 'BASIC'; selectedHeroConfig = null;
        document.getElementById('btn-basic').classList.add('active');
    } else {
        const hero = HERO_DB.find(h => h.id === mode);
        if (hero.placed) { alert("Ê≠§Ëã±ÈõÑÂè™ËÉΩÊîæ‰∏ÄÂÄãÔºÅ"); return; }
        buildMode = mode; selectedHeroConfig = hero;
        document.getElementById(`btn-${mode}`).classList.add('active');
    }
}

function startGameUI() {
    document.getElementById('draft-screen').style.display = 'none';
    document.getElementById('start-wave-btn').style.display = 'inline-block';
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameState = { 
    lives: 20, money: 300, wave: 1, 
    enemies: [], towers: [], projectiles: [], 
    isWaveActive: false, isEndingWave: false, spawnFinished: false 
};
let playerStats = { globalDamage: 0, globalRange: 0, globalFireRate: 60, goldMultiplier: 1.0, baseDamage: 15 };

class Enemy {
    constructor(wave) {
        const type = getRandomEnemyType();
        this.name = type.name; this.goldReward = type.gold;
        this.pathIndex = 0; 
        if (path && path.length > 0) { this.x = path[0].x; this.y = path[0].y; } 
        else { this.x = 0; this.y = 0; this.active = false; }
        
        this.baseSpeed = type.speed; 
        this.currentSpeed = this.baseSpeed;
        const scaleMultiplier = Math.pow(1.2, wave - 1);
        this.hp = Math.floor(type.baseHp * scaleMultiplier);
        this.maxHp = this.hp;
        this.active = true;
        this.blockedBy = null;
        this.slowEffect = 0; // Áï∂ÂâçÁ∑©ÈÄü
    }
    update() {
        if (!this.active) return;
        if (this.blockedBy && !this.blockedBy.active) this.blockedBy = null;
        if (this.blockedBy) return; 

        // üü¢ 3. Á∑©ÈÄüÈÇèËºØÂØ¶Ë£ù
        // Âü∫Á§éÈÄüÂ∫¶ * (1 - Á∑©ÈÄü‰øÇÊï∏)„ÄÇÂ¶ÇÊûúÊúâÁ∑©ÈÄüÔºåÂú∞ÊùøÈÄüÂ∫¶Ëá≥Â∞ë‰øùÁïô 0.5
        const actualSpeed = this.baseSpeed * Math.max(0.2, (1 - specialStats.slowFactor));
        this.currentSpeed = actualSpeed;

        let target = path[this.pathIndex + 1];
        if (!target) { this.active = false; updateLives(-1); return; }
        
        let dx = target.x - this.x, dy = target.y - this.y;
        let dist = Math.hypot(dx, dy);
        
        if(isNaN(dist) || dist < 1 || dist <= this.currentSpeed) {
            this.x = target.x; this.y = target.y; this.pathIndex++;
        } else { 
            this.x += (dx/dist)*this.currentSpeed; this.y += (dy/dist)*this.currentSpeed; 
        }
    }
    takeDamage(dmg) {
        this.hp -= dmg;
        if (this.hp <= 0 && this.active) {
            this.active = false;
            if (this.blockedBy) this.blockedBy.releaseBlock(this);
            updateMoney(Math.floor(this.goldReward * playerStats.goldMultiplier));
        }
    }
    draw() {
        if (!this.active) return;
        ctx.fillStyle = 'white'; ctx.font = "bold 16px Arial"; ctx.textAlign = "center";
        
        // üü¢ Á∑©ÈÄüÊôÇÈ°ØÁ§∫ËóçËâ≤Â§ñÊ°Ü
        if (specialStats.slowFactor > 0) ctx.strokeStyle = "#00bfff"; 
        else ctx.strokeStyle = "black";
        
        ctx.lineWidth = 3;
        ctx.strokeText(this.name, this.x, this.y); ctx.fillText(this.name, this.x, this.y);
        ctx.fillStyle = "red"; ctx.fillRect(this.x-20, this.y-15, 40, 4);
        ctx.fillStyle = "#00ff00"; ctx.fillRect(this.x-20, this.y-15, 40 * (this.hp/this.maxHp), 4);
    }
}

class Tower {
    constructor(x, y, heroConfig = null) { 
        this.x = x; this.y = y; this.cooldown = 0; this.level = 1; this.active = true;
        this.isHero = !!heroConfig;
        
        if (this.isHero) {
            this.heroId = heroConfig.id;
            this.baseDamage = heroConfig.stats.dmg;
            this.baseRange = heroConfig.stats.rng;
            this.fireRate = heroConfig.stats.spd;
            this.baseBlockCount = heroConfig.stats.block;
            this.blockCount = this.baseBlockCount;
            this.totalCost = heroConfig.cost;
            this.name = heroConfig.name;
            this.skillConfig = heroConfig.skill;
            
            // üü¢ ËÆÄÂèñÊîªÊìäÈ°ûÂûã
            this.attackType = heroConfig.attackType || 'PROJECTILE';
            this.attackAnimLoop = (this.attackType === 'PENETRATE'); // Á••Â≠êÈ°ûÁ©øÈÄèÊâçÈúÄË¶Å Loop
            
            this.media = {};
            const keys = ['front_idle', 'front_attack', 'front_skill_begin', 'front_skill_loop', 'front_skill_end',
                          'back_idle', 'back_attack', 'back_skill_begin', 'back_skill_loop', 'back_skill_end'];
            keys.forEach(k => {
                if (heroConfig.anim[k]) {
                    let isLoop = false;
                    if (k.includes('idle') || k.includes('skill_loop')) isLoop = true;
                    if (k.includes('attack')) isLoop = this.attackAnimLoop;
                    this.media[k] = this.createVideo(heroConfig.anim[k], isLoop);
                }
            });

            this.dir = 0; this.isAttacking = false; this.blockedEnemies = [];
            this.skillActive = false; this.skillState = 'IDLE'; 
            this.skillTimer = 0; 
            this.skillCDTimer = 0; // üü¢ ÊäÄËÉΩÂÜ∑ÂçªË®àÊôÇÂô®
            this.playingAttackOneShot = false;

        } else {
            this.baseDamage = playerStats.baseDamage; this.baseRange = 100;
            this.fireRate = playerStats.globalFireRate; this.totalCost = 50;
            this.name = "Âü∫Á§éÂ°î";
            this.attackType = 'PROJECTILE';
        }
    }

    createVideo(src, loop) {
        const v = document.createElement('video'); v.src = src; v.muted = true; v.loop = loop; 
        v.autoplay = false; v.playsInline = true; return v;
    }

    getDamage() { 
        if (this.isHero) return this.baseDamage + playerStats.globalDamage + (this.level-1) * 20;
        else return playerStats.baseDamage + playerStats.globalDamage + (this.level-1) * 15; 
    }
    
    getRange() { return this.isHero ? this.baseRange + (this.level-1)*5 : this.baseRange + playerStats.globalRange + (this.level-1)*15; }
    getFireRate() { return this.isHero ? this.fireRate : playerStats.globalFireRate; }
    getAttacksPerSecond() { return (60 / this.getFireRate()).toFixed(2); }

    upgrade() { 
        this.level++;
        if (this.isHero) this.totalCost += this.level * 200; 
        else this.totalCost += (this.level - 1) * 150;
    }

    triggerSkill() {
        // üü¢ 4. ÊäÄËÉΩÈôêÂà∂ÔºöÊ≥¢Ê¨°ÈñãÂßãÂæå & ÁÑ°ÂÜ∑ÂçªÊôÇ
        if (!gameState.isWaveActive) { alert("ÊäÄËÉΩÂè™ËÉΩÂú®Êà∞È¨•Ê≥¢Ê¨°‰∏≠‰ΩøÁî®ÔºÅ"); return; }
        if (!this.skillConfig || this.skillActive || this.skillCDTimer > 0) return;
        
        this.skillActive = true;
        this.skillState = 'BEGIN';
        this.skillTimer = this.skillConfig.duration * 60;
        // Ë®≠ÂÆö CD (Áßí -> ÂπÄ)
        this.skillCDTimer = (this.skillConfig.cooldown || 30) * 60;

        if (this.skillConfig.type === 'MONEY') {
            this.blockCount = 0; 
            this.blockedEnemies.forEach(e => e.blockedBy = null);
            this.blockedEnemies = [];
        }
        this.playAnim('skill_begin');
    }

    playAnim(type) {
        if(!this.media) return;
        Object.values(this.media).forEach(v => { v.pause(); v.currentTime = 0; });
        const prefix = (this.dir === 3) ? "back_" : "front_";
        if (this.media[prefix + type]) this.media[prefix + type].play().catch(()=>{});
    }

    update() {
        // üü¢ ÊäÄËÉΩ CD ÂÄíÊï∏
        if (this.skillCDTimer > 0) this.skillCDTimer--;

        if (this.isHero) {
            // SKILL Logic
            if (this.skillActive) {
                if (gameState.frame % 60 === 0 && this.skillConfig.type === 'MONEY') updateMoney(this.skillConfig.value);
                const prefix = (this.dir === 3) ? "back_" : "front_";
                if (this.skillState === 'BEGIN') {
                    if (!this.media[prefix + 'skill_begin'] || this.media[prefix + 'skill_begin'].ended) { this.skillState = 'LOOP'; this.playAnim('skill_loop'); }
                } else if (this.skillState === 'LOOP') {
                    this.skillTimer--; if (this.skillTimer <= 0) { this.skillState = 'END'; this.playAnim('skill_end'); }
                } else if (this.skillState === 'END') {
                    if (!this.media[prefix + 'skill_end'] || this.media[prefix + 'skill_end'].ended) {
                        this.skillActive = false; this.skillState = 'IDLE'; this.blockCount = this.baseBlockCount;
                    }
                }
                return;
            }

            // Target Finding
            this.blockedEnemies = this.blockedEnemies.filter(e => e.active);
            if (this.blockedEnemies.length < this.blockCount) {
                gameState.enemies.forEach(e => {
                    if (e.active && !e.blockedBy && this.blockedEnemies.length < this.blockCount) {
                        if (Math.hypot(e.x - this.x, e.y - this.y) < 40) { e.blockedBy = this; this.blockedEnemies.push(e); }
                    }
                });
            }

            let hasTarget = false; const range = this.getRange(); const width = 40; 
            gameState.enemies.forEach(e => { if (e.active && this.isInRectRange(e, range, width)) hasTarget = true; });
            
            if (this.isAttacking !== hasTarget) { this.isAttacking = hasTarget; this.updateVideoState(); }
            if (!this.isAttacking && this.media && !this.media.front_idle.playing) this.updateVideoState();

            if (this.cooldown > 0) this.cooldown--;
            if (this.cooldown <= 0 && hasTarget) {
                let vx = 0, vy = 0;
                // üü¢ Ê†πÊìöÊîªÊìäÈ°ûÂûãÊ±∫ÂÆöÂΩàÈÄü
                let bulletSpeed = (this.attackType === 'RECT') ? 15 : 10;

                if (this.dir === 0) vx = bulletSpeed; else if (this.dir === 1) vy = bulletSpeed;
                else if (this.dir === 2) vx = -bulletSpeed; else if (this.dir === 3) vy = -bulletSpeed;
                
                // üü¢ Ê†πÊìö CSV ÂÆöÁæ©Áî¢Áîü Projectile
                if (this.attackType === 'RECT') {
                    gameState.projectiles.push(new Projectile(this.x, this.y, vx, vy, this.getDamage(), false, true, 60));
                } else if (this.attackType === 'PENETRATE') {
                    gameState.projectiles.push(new Projectile(this.x, this.y, vx, vy, this.getDamage(), true, false, 0));
                } else {
                    gameState.projectiles.push(new Projectile(this.x, this.y, vx, vy, this.getDamage(), false, false, 0));
                }

                this.cooldown = this.getFireRate();

                if (!this.attackAnimLoop) {
                    this.playingAttackOneShot = true;
                    this.playAnim('attack');
                    const prefix = (this.dir === 3) ? "back_" : "front_";
                    const vid = this.media[prefix + 'attack'];
                    if (vid) vid.onended = () => { this.playingAttackOneShot = false; };
                }
            }
        } else {
            // Basic Tower Logic
            if (this.cooldown > 0) this.cooldown--;
            if (this.cooldown <= 0) {
                let target = null, minDist = Infinity, range = this.getRange();
                gameState.enemies.forEach(e => { if (!e.active) return; let dist = Math.hypot(e.x - this.x, e.y - this.y); if (dist <= range && dist < minDist) { minDist = dist; target = e; } });
                if (target) {
                    let dx = target.x - this.x, dy = target.y - this.y, dist = Math.hypot(dx, dy);
                    let vx = (dx/dist)*10, vy = (dy/dist)*10;
                    gameState.projectiles.push(new Projectile(this.x, this.y, vx, vy, this.getDamage(), false, false, 0));
                    this.cooldown = this.getFireRate();
                }
            }
        }
    }

    updateVideoState() {
        if(!this.media || this.playingAttackOneShot) return;
        Object.values(this.media).forEach(v => { if(v && !v.src.includes('Skill')) v.pause(); });
        const prefix = (this.dir === 3) ? "back_" : "front_";
        let key = "idle";
        if (this.attackAnimLoop && this.isAttacking) key = "attack";
        if (this.media[prefix + key]) this.media[prefix + key].play().catch(()=>{});
    }

    isInRectRange(e, range, width) {
        const dx = e.x - this.x; const dy = e.y - this.y;
        if (this.dir === 0) return dx > 0 && dx < range && Math.abs(dy) < width;
        if (this.dir === 1) return dy > 0 && dy < range && Math.abs(dx) < width;
        if (this.dir === 2) return dx < 0 && dx > -range && Math.abs(dy) < width;
        if (this.dir === 3) return dy < 0 && dy > -range && Math.abs(dx) < width;
        return false;
    }

    draw() {
        if (this.isHero) {
            let activeVideo = null;
            const prefix = (this.dir === 3) ? "back_" : "front_";
            if (this.skillActive) {
                if (this.skillState === 'BEGIN') activeVideo = this.media[prefix + 'skill_begin'];
                else if (this.skillState === 'LOOP') activeVideo = this.media[prefix + 'skill_loop'];
                else activeVideo = this.media[prefix + 'skill_end'];
            } else {
                if (this.playingAttackOneShot) activeVideo = this.media[prefix + 'attack'];
                else if (this.attackAnimLoop && this.isAttacking) activeVideo = this.media[prefix + 'attack'];
                else activeVideo = this.media[prefix + 'idle'];
            }

            ctx.save(); ctx.translate(this.x, this.y); 
            if (this.dir === 2) ctx.scale(-1, 1);
            if (activeVideo && activeVideo.readyState >= 2) ctx.drawImage(activeVideo, -75, -110, 150, 150);
            ctx.restore(); 
            
            ctx.fillStyle = '#fff'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`Lv.${this.level}`, this.x, this.y - 75);
            ctx.fillStyle = '#f1c40f';
            
            // üü¢ È°ØÁ§∫ÊäÄËÉΩÁãÄÊÖã (CD‰∏≠ / Ê∫ñÂÇôÂ∞±Á∑í)
            let statusText = `üõ°Ô∏è ${this.blockedEnemies.length}/${this.blockCount}`;
            if (this.skillActive) statusText = "SKILL";
            else if (this.skillCDTimer > 0) statusText = `CD: ${(this.skillCDTimer/60).toFixed(1)}s`;
            
            ctx.fillText(statusText, this.x, this.y + 10);
            if (selectedTower === this) this.drawRangeRect(this.getRange(), 40);
        } else {
            ctx.fillStyle = this.level === 1 ? '#4a90e2' : (this.level === 2 ? '#9b59b6' : '#f1c40f');
            ctx.fillRect(this.x-15, this.y-15, 30, 30);
            ctx.fillStyle = '#fff'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText("Lv."+this.level, this.x, this.y - 23);
            if(selectedTower === this) { ctx.strokeStyle='#00bcd4'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(this.x,this.y,this.getRange(),0,Math.PI*2); ctx.stroke(); }
        }
    }
    drawRangeRect(range, width) {
        ctx.save(); ctx.translate(this.x, this.y);
        if (this.dir === 1) ctx.rotate(Math.PI / 2); if (this.dir === 2) ctx.rotate(Math.PI); if (this.dir === 3) ctx.rotate(-Math.PI / 2);
        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)'; ctx.fillRect(0, -width, range, width * 2); 
        ctx.lineWidth = 1; ctx.strokeStyle = '#ffd700'; ctx.strokeRect(0, -width, range, width * 2); ctx.restore();
    }
}

class Projectile {
    constructor(x, y, vx, vy, damage, isPenetrating, isRect = false, rectWidth = 0) { 
        this.startX = x; this.startY = y; this.vx = vx; this.vy = vy; this.damage = damage; this.active = true; 
        this.isPenetrating = isPenetrating; this.hitList = [];
        this.speed = Math.hypot(vx, vy); this.normX = vx/this.speed; this.normY = vy/this.speed; this.dist = 0;
        
        this.isRect = isRect;
        this.rectWidth = rectWidth;
        this.visible = !isRect;
    }
    update() {
        if (!this.active) return; this.dist += this.speed;
        
        if (this.isPenetrating && !this.isRect) { 
            let off = Math.sin(this.dist * 0.05) * 20; 
            this.x = this.startX + this.normX * this.dist - this.normY * off; 
            this.y = this.startY + this.normY * this.dist + this.normX * off; 
        } else { 
            this.x = this.startX + this.normX * this.dist; 
            this.y = this.startY + this.normY * this.dist; 
        }

        if (this.x<0||this.x>canvas.width||this.y<0||this.y>canvas.height) this.active = false;
        
        gameState.enemies.forEach(e => {
            if (!e.active || !this.active) return;
            if (this.isPenetrating && this.hitList.includes(e)) return;
            
            let isHit = false;
            if (this.isRect) {
                const range = this.rectWidth / 2;
                if (Math.abs(e.x - this.x) < range && Math.abs(e.y - this.y) < range) isHit = true;
            } else {
                if (Math.hypot(e.x - this.x, e.y - this.y) < 25) isHit = true;
            }

            if (isHit) { 
                e.takeDamage(this.damage);
                
                // üü¢ 5. ÁàÜÁÇ∏ (Splash) ÂØ¶Ë£ù
                if (specialStats.splashRadius > 0) {
                    gameState.enemies.forEach(other => {
                        if (other !== e && other.active && Math.hypot(other.x - e.x, other.y - e.y) < specialStats.splashRadius) {
                            other.takeDamage(this.damage * 0.5); // ÁàÜÁÇ∏ÂÇ∑ÂÆ≥ 50%
                            // Á∞°ÂñÆÁàÜÁÇ∏ÁâπÊïà (ÂèØË¶ñÂåñ)
                            ctx.beginPath(); ctx.arc(e.x, e.y, specialStats.splashRadius, 0, Math.PI*2);
                            ctx.fillStyle = 'rgba(255, 165, 0, 0.3)'; ctx.fill();
                        }
                    });
                }

                if(this.isPenetrating) this.hitList.push(e); 
                else this.active = false; 
            }
        });
    }
    draw() { 
        if (!this.active || !this.visible) return; 
        ctx.fillStyle = this.isPenetrating ? 'rgba(0,191,255,0.6)' : '#ffeb3b'; 
        ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill(); 
    }
}

let selectedTower = null; const upgradeMenu = document.getElementById('upgrade-menu');
canvas.addEventListener('mousemove', (e) => { const r = canvas.getBoundingClientRect(); mousePos.x = e.clientX - r.left; mousePos.y = e.clientY - r.top; });
canvas.addEventListener('mousedown', (e) => {
    const r = canvas.getBoundingClientRect(), x = e.clientX - r.left, y = e.clientY - r.top;
    const clicked = gameState.towers.find(t => Math.hypot(t.x-x, t.y-y) < 30);
    if (clicked) openUpgradeMenu(clicked, e.clientX, e.clientY);
    else {
        closeMenu();
        if (!gameState.towers.some(t => Math.hypot(t.x-x, t.y-y) < 30)) {
            if (buildMode === 'BASIC' && gameState.money >= 50) { gameState.towers.push(new Tower(x, y)); updateMoney(-50); }
            else if (selectedHeroConfig && !selectedHeroConfig.placed && gameState.money >= selectedHeroConfig.cost) {
                gameState.towers.push(new Tower(x, y, selectedHeroConfig)); updateMoney(-selectedHeroConfig.cost);
                selectedHeroConfig.placed = true; document.getElementById(`btn-${selectedHeroConfig.id}`).classList.add('disabled'); selectBuildMode('BASIC');
            }
        }
    }
});

function drawBuildPreview() {
    if (selectedTower) return;
    const overlap = gameState.towers.some(t => Math.hypot(t.x - mousePos.x, t.y - mousePos.y) < 30);
    ctx.globalAlpha = 0.5;
    if (buildMode !== 'BASIC' && selectedHeroConfig) {
        const range = selectedHeroConfig.stats.rng, width = 40;
        ctx.fillStyle = overlap ? 'rgba(255,0,0,0.2)' : 'rgba(255, 215, 0, 0.3)';
        ctx.fillRect(mousePos.x, mousePos.y - width, range, width * 2);
        ctx.lineWidth = 1; ctx.strokeStyle = '#ffd700'; ctx.strokeRect(mousePos.x, mousePos.y - width, range, width * 2);
    } else {
        ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, 100 + playerStats.globalRange, 0, Math.PI*2);
        ctx.fillStyle = overlap ? 'rgba(255,0,0,0.2)' : 'rgba(74, 144, 226, 0.2)'; ctx.fill();
    }
    ctx.globalAlpha = 1.0;
}

function openUpgradeMenu(tower, mx, my) {
    selectedTower = tower;
    document.getElementById('menu-title').innerText = `${tower.name} Lv.${tower.level}`;
    document.getElementById('menu-dmg').innerText = Math.floor(tower.getDamage());
    document.getElementById('menu-rng').innerText = Math.floor(tower.getRange());
    document.getElementById('menu-spd').innerText = tower.getAttacksPerSecond() + "/s";
    document.getElementById('menu-blk').innerText = tower.isHero ? tower.blockCount : 0;
    
    const btnSkill = document.getElementById('btn-skill-action');
    if (tower.isHero && tower.skillConfig) {
        btnSkill.style.display = 'block';
        if (tower.skillActive) { btnSkill.innerText = "ÊäÄËÉΩÁôºÂãï‰∏≠..."; btnSkill.classList.add('disabled'); btnSkill.disabled = true; }
        else if (tower.skillCDTimer > 0) { btnSkill.innerText = `CD: ${(tower.skillCDTimer/60).toFixed(1)}s`; btnSkill.classList.add('disabled'); btnSkill.disabled = true; }
        else { btnSkill.innerText = "üåü ÁôºÂãïÊäÄËÉΩ"; btnSkill.classList.remove('disabled'); btnSkill.disabled = false; }
    } else btnSkill.style.display = 'none';

    const btnRot = document.getElementById('btn-rotate-action');
    if (tower.isHero) { btnRot.style.display = 'block'; btnRot.innerText = `üîÑ ÊóãËΩâ (${['Âè≥','‰∏ã','Â∑¶','‰∏ä'][tower.dir]})`; } else btnRot.style.display = 'none';

    upgradeMenu.style.display = 'flex';
    const menuRect = upgradeMenu.getBoundingClientRect();
    const containerRect = document.getElementById('game-container').getBoundingClientRect();
    
    let newX = mx + 10;
    let newY = my - 120;
    if (newX + menuRect.width > containerRect.width) newX = mx - menuRect.width - 20; 
    if (newY < 0) newY = 10;
    if (newY + menuRect.height > containerRect.height) newY = containerRect.height - menuRect.height - 10;

    upgradeMenu.style.left = newX + 'px'; 
    upgradeMenu.style.top = newY + 'px';
}

function rotateSelectedTower() {
    if (selectedTower && selectedTower.isHero) {
        selectedTower.dir = (selectedTower.dir + 1) % 4;
        const dirs = ['Âè≥', '‰∏ã', 'Â∑¶', '‰∏ä'];
        document.getElementById('btn-rotate-action').innerText = `üîÑ ÊóãËΩâ (${dirs[selectedTower.dir]})`;
    }
}

function upgradeSelectedTower() { if(selectedTower && gameState.money >= 150) { updateMoney(-150); selectedTower.upgrade(); closeMenu(); } }
function activateSkill() { if(selectedTower) { selectedTower.triggerSkill(); closeMenu(); } }
function sellSelectedTower() { if(!selectedTower)return; updateMoney(Math.floor(selectedTower.totalCost*0.7)); if(selectedTower.isHero) { const h = HERO_DB.find(i=>i.id===selectedTower.heroId); if(h){ h.placed=false; document.getElementById(`btn-${h.id}`).classList.remove('disabled'); }} selectedTower.active=false; gameState.towers=gameState.towers.filter(t=>t!==selectedTower); closeMenu(); }
function closeMenu() { selectedTower = null; upgradeMenu.style.display = 'none'; }
function updateMoney(v) { gameState.money += v; document.getElementById('money').innerText = gameState.money; }
function updateLives(v) { gameState.lives += v; document.getElementById('lives').innerText = gameState.lives; if(gameState.lives<=0) { alert("Game Over"); location.reload(); } }

function startWave() { if(gameState.isWaveActive)return; gameState.isWaveActive=true; gameState.isEndingWave=false; gameState.spawnFinished=false; document.getElementById('start-wave-btn').style.display='none'; closeMenu(); let max=5+(gameState.wave*3), count=0; const s = setInterval(() => { if(!gameState.isWaveActive){clearInterval(s);return;} try{gameState.enemies.push(new Enemy(gameState.wave));}catch(e){} count++; if(count>=max){clearInterval(s); gameState.spawnFinished=true;} }, Math.max(200, 800-(gameState.wave*20))); }
function endWave() { gameState.isWaveActive=false; gameState.enemies=[]; gameState.projectiles=[]; gameState.wave++; document.getElementById('wave').innerText=gameState.wave; showDraft(); }
function showDraft() { const box=document.getElementById('cards-container'); box.innerHTML=''; const pool=(loadedUpgrades.length?loadedUpgrades:[{name:"Backup",desc:"Data Error",apply:()=>playerStats.globalDamage+=1}]); for(let i=0;i<3;i++){ const u=pool[Math.floor(Math.random()*pool.length)]; const d=document.createElement('div'); d.className='card'; d.innerHTML=`<h3 style="color:#00bcd4">${u.name}</h3><p style="color:#ccc">${u.desc}</p>`; d.onclick=()=>{u.apply();document.getElementById('draft-screen').style.display='none';document.getElementById('start-wave-btn').style.display='inline-block';}; box.appendChild(d); } document.getElementById('draft-screen').style.display='flex'; }

function loop() {
    try {
        gameState.frame = (gameState.frame||0)+1; ctx.fillStyle='#333'; ctx.fillRect(0,0,canvas.width,canvas.height);
        if(path.length){ ctx.strokeStyle='#555'; ctx.lineWidth=40; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); for(let i=1;i<path.length;i++)ctx.lineTo(path[i].x,path[i].y); ctx.stroke(); }
        
        gameState.towers.forEach(t=>t.update()); gameState.towers.forEach(t=>t.draw());
        gameState.enemies.forEach(e=>{e.update();e.draw();}); gameState.projectiles.forEach(p=>{p.update();p.draw();});
        drawBuildPreview();
        
        document.getElementById('enemy-count').innerText = gameState.enemies.filter(e => e.active).length;

        if(gameState.isWaveActive && gameState.spawnFinished && !gameState.enemies.some(e=>e.active) && !gameState.isEndingWave) { gameState.isEndingWave=true; setTimeout(endWave,500); }
    } catch(e) {
        console.error("Game Loop Error:", e);
    }
    requestAnimationFrame(loop);
}
initGameData(); loop();
</script>
</body>
</html>
